<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xie&#39;s Exploration</title>
  
  <subtitle>Any idea or discussion is highly welcomed.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mhxie.me/"/>
  <updated>2018-10-08T05:15:43.938Z</updated>
  <id>https://mhxie.me/</id>
  
  <author>
    <name>Minghao Xie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《深度工作》读书笔记</title>
    <link href="https://mhxie.me/2018/03/07/Deep%20Work/"/>
    <id>https://mhxie.me/2018/03/07/Deep Work/</id>
    <published>2018-03-07T23:13:45.000Z</published>
    <updated>2018-10-08T05:15:43.938Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://calnewport.com/" target="_blank" rel="external">卡尔·纽波特(Cal Newport)</a>是麻省理工学院计算机科学博士，现在是乔治城大学计算机科学副教授。</p><blockquote><p>作者创立的“深度工作”概念，其含义为在无干扰的状态下进行专注的职业活动，使个人的认知能力达到极限。而正因为当前社会深度工作能力的日益稀缺，其与经济成功的关系也变得日渐紧密起来。</p></blockquote><a id="more"></a><h3 id="Rule-1-工作要深入"><a href="#Rule-1-工作要深入" class="headerlink" title="Rule 1. 工作要深入"></a>Rule 1. 工作要深入</h3><p>选定你的深度哲学：禁欲主义哲学；双峰哲学；节奏哲学；记者哲学</p><p>习惯化：指定深度工作的场所，设定具体的时间框架，加入惯例和固定程序，最小化意志力消耗，将过程保持为离散型的挑战而非漫无尽头的马拉松</p><p>要有大手笔</p><p>不要独自工作</p><p>像经商一样执行：4DX - 关注点方法放到极端重要的事情上；抓住引领性指标（而非滞后型指标）；准备一个醒目的计分板；定期问责；</p><p>图安逸：安逸时光有助于提升洞察力；有利于补充深度工作所需的能量；晚间安逸时光里放下的工作往往没有那么重要；—&gt; 每个工作日都要有严格的终结点（完工仪式）</p><h3 id="Rule-2-拥抱无聊"><a href="#Rule-2-拥抱无聊" class="headerlink" title="Rule 2. 拥抱无聊"></a>Rule 2. 拥抱无聊</h3><p>针对离线时间的阶段性训练操</p><p>工作日外的时间也坚持按计划使用网路</p><p>有成果地冥想</p><h3 id="Rule-3-远离社交媒体"><a href="#Rule-3-远离社交媒体" class="headerlink" title="Rule 3. 远离社交媒体"></a>Rule 3. 远离社交媒体</h3><p>网络使用习惯中采用关键少数原则：在许多情境中，80%的已知效果源自20%的可能原因。</p><h3 id="Rule-4-摒弃浮浅"><a href="#Rule-4-摒弃浮浅" class="headerlink" title="Rule 4. 摒弃浮浅"></a>Rule 4. 摒弃浮浅</h3><p>一天的每一分钟都要做好计划</p><p>定量分析每一项工作的深度</p><p>5点半之前结束工作</p><p>变得不容易联系到</p><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><ol><li>《Deep Work: Rules for Focused Success in a Distracted World》</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://calnewport.com/&quot;&gt;卡尔·纽波特(Cal Newport)&lt;/a&gt;是麻省理工学院计算机科学博士，现在是乔治城大学计算机科学副教授。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作者创立的“深度工作”概念，其含义为在无干扰的状态下进行专注的职业活动，使个人的认知能力达到极限。而正因为当前社会深度工作能力的日益稀缺，其与经济成功的关系也变得日渐紧密起来。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Essay" scheme="https://mhxie.me/categories/Essay/"/>
    
    
      <category term="efficiency" scheme="https://mhxie.me/tags/efficiency/"/>
    
      <category term="work" scheme="https://mhxie.me/tags/work/"/>
    
      <category term="plan" scheme="https://mhxie.me/tags/plan/"/>
    
      <category term="note" scheme="https://mhxie.me/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>Domain analysis —— 进入新领域的必由之路</title>
    <link href="https://mhxie.me/2017/03/10/Domain%20Analysis/"/>
    <id>https://mhxie.me/2017/03/10/Domain Analysis/</id>
    <published>2017-03-11T00:38:02.000Z</published>
    <updated>2018-10-08T05:00:37.508Z</updated>
    
    <content type="html"><![CDATA[<p>进入一个未知的崭新领域，往往伴随着新奇与迷惑，在如今这个信息爆炸的时代尤其如此。最近在阅读综述时偶然发现Domain analysis这个terminology，看来其实前人早就为这个问题准备好了方法论，为了更好地继续进行我之前的探索，我也在这里总结一下Domain analysis相关的材料。希望从中获得一些做研究，写综述，作总结的一些启发。</p><a id="more"></a><h2 id="什么是domain-analysis"><a href="#什么是domain-analysis" class="headerlink" title="什么是domain analysis"></a>什么是domain analysis</h2><p>Domain analysis最初是来源于SE(Software Engineering)的一个概念，加州大学Irvine分校的信息计算机科学系的教授 James Neighbors在1980年提出：</p><blockquote><p>The concept of domain analysis is introduced to describe the activity of identifying the objects and operations of a class of similar systems in a particular problem domain. A domain analysis is represented by a domain-specific language, a prettyprinter, source-to- source transformations, and software components.  </p></blockquote><p>1990年，软件工程学家Kang, Kyo C.在他的论文Feature-Oriented Domain Analysis (FODA) Feasibility Study中对domain analysis有了更加详细的定义，他认为domain analysis是：</p><blockquote><p>“The process of identifying, collecting, organizing, and representing the relevant information in a domain based on the study of existing systems and their development histories, knowledge captured from domain experts, underlying theory, and emerging technology within the domain.“  </p></blockquote><p>这个定义相比之下更具有普适意义，而这篇论文，也成了这个概念应用的被引用的最广泛的论文之一，FODA作为一种经典的领域分析方法，在计算机科学领域中大放异彩。</p><p>在SE之外，domain analysis也被应用于LIS(library and information science)。</p><p>概括来说，LIS中的domain analysis就是从文献的标题及内容中，提取出该领域的关键字群组，经过字词群组的整合之后，整理出该领域所蕴含的钙奶呢语文献架构。</p><p>Hjørland认为domain analysis应该由领域专家和LIS专家合作进行。而我们作为普通的科研人员，在了解一些domain analysis的方法论之后，也能够更好地整理自己研究领域的知识。</p><h2 id="Domain-analysis的常用方法"><a href="#Domain-analysis的常用方法" class="headerlink" title="Domain analysis的常用方法"></a>Domain analysis的常用方法</h2><h3 id="LIS领域："><a href="#LIS领域：" class="headerlink" title="LIS领域："></a>LIS领域：</h3><p>Hjørland认为LIS领域的问题在于一般的学科专家并不是IS的专家，而domain analytic approach试图解决这些问题，提供学科专家对其领域的专业知识进行整理的方法。他从过去中的研究中整理出了十一种方法：</p><ol><li>Producing literature guides or subject gateways</li><li>Constructing special classifications and thesauri</li><li>Indexing and retrieving specialities</li><li>Empirical user studies</li><li>Bibliometrical studies</li><li>Historical studies</li><li>Document and genre studies</li><li>Epistemological and critical studies</li><li>Terminological studies, language for special purpose  LSP),database semantics and discourse studies</li><li>Structures and institutions in scientific communication</li><li>Scientific cognition, expert knowledge and artificial intelligence  AI)</li></ol><h3 id="SE领域"><a href="#SE领域" class="headerlink" title="SE领域"></a>SE领域</h3><ul><li>DARE: Domain Analysis and Reuse Environment</li><li>Feature-Oriented Domain Analysis (FODA)</li><li>IDEF0 for Domain Analysis</li><li>Model Oriented Domain Analysis and Engineering</li></ul><h2 id="Domain-analysis的过程"><a href="#Domain-analysis的过程" class="headerlink" title="Domain analysis的过程"></a>Domain analysis的过程</h2><p>LIS中的一种过程：</p><p>(一)第一阶段 - 领域与知识范围的确认:<br> 对选定的领域进行名词整理、定义与范围确认，将此领域主题的同义词整理出来，列出通用的同义词或者比较多人使用的名词，并对此领域进行定义与范围的确认。</p><p>(二)第二阶段 - 领域知识架构的形成:<br>搜集这一领域相关的书籍、文献、分类表、网络资源等，归纳出现行的各种领域知识架构。</p><p>(三)第三阶段 - 确认和调整领域知识架构：<br>经由问卷调查，了解这一领域的多名专家对已经归纳出的知识架构有什么看法，并将最多专家认同的领域知识架构与领域专家再次讨论，修改得出最终的领域知识架构。<br>LIS的领域分析，更像是建立起了一个index，或者说找到一种taxonomy。最值得借鉴的是第一阶段，如果不事先确定好领域的范围，整理好领域内的一些概念，可能接下来会走不少弯路。</p><p>SE领域，论文FODA中将domain analysis主要分为以下三个阶段：</p><ol><li>Context analysis: defining the extent (or bounds) of a domain for analysis.</li><li>Domain modelling: describing the problems within the domain that are ad-dressed by software.</li><li>Architecture modelling: creating the software architecture(s) that implements a solution to the problems in the domain.</li></ol><p>SE的领域分析更加复杂和和专业化，它的最终目的是从已有的系统中提取出可复用的部分，避免以后的重复研究。SE中有不少值得一看的关于领域分析的方法论，希望以后能有时间研读。</p><p>References:</p><p>[1] Kang, Kyo C., Sholom G. Cohen, James A. Hess, William E. Novak, and A. Spencer Peterson. Feature-oriented domain analysis (FODA) feasibility study. No. CMU/SEI-90-TR-21. Carnegie-Mellon Univ Pittsburgh Pa Software Engineering Inst, 1990.<br>[2] 陳奕璇、阮明淑 （2006）。領域分析之方法學研究。Workshop of Recent Advances in Library and Information Science【線上查詢】，Autumn 2006。<a href="http://moodle.lips.tw/~tcasist/" target="_blank" rel="external">http://moodle.lips.tw/~tcasist/</a><br>[3] Hjørland, Birger. “Domain analysis in information science: eleven approaches–traditional as well as innovative.” Journal of documentation 58, no. 4 (2002): 422-462.<br>[4]  <a href="https://www.wikiwand.com/en/Domain_analysis" target="_blank" rel="external">https://www.wikiwand.com/en/Domain_analysis</a><br>[5] <a href="https://www.wikiwand.com/en/Domain_engineering" target="_blank" rel="external">https://www.wikiwand.com/en/Domain_engineering</a><br>[6] Neighbors, James Milne. “Software construction using components.” PhD diss., University of California, Irvine, 1980.  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;进入一个未知的崭新领域，往往伴随着新奇与迷惑，在如今这个信息爆炸的时代尤其如此。最近在阅读综述时偶然发现Domain analysis这个terminology，看来其实前人早就为这个问题准备好了方法论，为了更好地继续进行我之前的探索，我也在这里总结一下Domain analysis相关的材料。希望从中获得一些做研究，写综述，作总结的一些启发。&lt;/p&gt;
    
    </summary>
    
      <category term="Theory" scheme="https://mhxie.me/categories/Theory/"/>
    
    
      <category term="methodology" scheme="https://mhxie.me/tags/methodology/"/>
    
      <category term="research" scheme="https://mhxie.me/tags/research/"/>
    
  </entry>
  
  <entry>
    <title>SDN workshop Collection - Last Update on Feb 25</title>
    <link href="https://mhxie.me/2017/02/22/SDN-workshop-Collection/"/>
    <id>https://mhxie.me/2017/02/22/SDN-workshop-Collection/</id>
    <published>2017-02-23T07:32:23.000Z</published>
    <updated>2018-10-08T05:01:43.038Z</updated>
    
    <content type="html"><![CDATA[<p>最近整理了SDN相关的会议以及它们的Topics of Interest，希望能够从中看出SDN发展的一些趋势。持续更新…</p><a id="more"></a><p>研讨会：</p><p>HotSDN(SIGCOMM)/SOSR(SIGCOMM, ONS), CoolSDN(ICNP), SDNFLEX(NetSys), EWSDN, ManSDN/NFV(CNSM)</p><p>发表有SDN相关论文会议：</p><ul><li>A类: SIGCOMM, INFOCOM</li><li>B类: CoNEXT, ICNP, IMC, NSDI</li><li>C类: HotNets, LCN, ANCS, Globecom, ICC, ICCCN, IM, NOMS</li><li>其他: PAM, Hot-ICE, INM/WREN, NDSS,USENIX ATC, POPL, PADL, OSDI, ICFP</li></ul><p>计算机网络领域顶级学术会议SIGCOMM在2012年召开了第一届HotSDN研讨会，算是最早一个也是最有名的一个针对SDN的研讨会了。</p><p><a href="http://conferences.sigcomm.org/sigcomm/2012/hotsdn.php" target="_blank" rel="external">HotSDN 2012</a><br><a href="http://conferences.sigcomm.org/sigcomm/2013/hotsdn.php" target="_blank" rel="external">HotSDN 2013</a></p><ul><li>Applications of SDN in home, wireless, cellular, enterprise, data-center, and backbone networks</li><li>2012: Application of SDN to network management, <strong>performance</strong> monitoring, security, etc.</li><li>2013: Applications of SDN to network management, monitoring, security, etc.</li><li>2012: Virtual appliances (e.g., firewalls, intrusion detection systems, load balancers, etc.) on SDN</li><li>2013: Virtual appliances (e.g., firewalls, intrusion detection systems, load balancers, etc.) built using SDN</li></ul><ul><li>2012: Virtualization <strong>support</strong> in SDN</li><li>2013: Virtualization in SDN</li></ul><ul><li>Switch designs for SDN</li><li>Application Programming Interfaces for SDN</li><li>Control and management software <strong>stack</strong> for SDN</li><li>Programming languages, verification techniques, and tools for SDN</li><li>Performance evaluation of SDN network elements and controllers</li><li>Experiences deploying SDN technology and applications in operational networks</li><li>2012: Hybrid SDN approaches (integration with other control planes)</li><li>2013: Hybrid SDN approaches (not in 2014)</li><li>Transitioning existing networks to SDN</li></ul><ul><li>Placement and factoring of SDN control logic</li></ul><ul><li>Distributed systems abstractions for managing switches and controllers in SDN(2013 only)</li></ul><p>到了2014年变动就比较大：</p><p><a href="http://conferences.sigcomm.org/sigcomm/2014/hotsdn.php" target="_blank" rel="external">HotSDN 2014</a></p><ul><li>SDN applications to home, wireless, cellular, enterprise, data-center, and backbone networks</li><li>SDN applications to network management, monitoring, security, etc.</li><li>Security of SDN infrastructure(2014 only)</li><li>Virtualization in SDNs</li><li>Switch designs for SDN</li><li>Application programming interfaces for SDNs(2014 only)</li><li>Control and management software for SDNs</li><li>Programming languages, verification techniques, and tools for SDNs</li><li>Performance evaluation of SDN switches and controllers</li><li>Experiences deploying SDN technology and applications in operational networks</li><li>Transitioning existing networks to SDN</li><li>Placement and factoring of SDN control logic</li><li>SDN-like control applied to other settings, e.g., transport, physical layer, wireless, etc.(2014 only)</li></ul><p><a href="http://opennetsummit.org/2015-archive/sosr/" target="_blank" rel="external">SOSR 2015</a><br><a href="http://conferences.sigcomm.org/sosr/2016/" target="_blank" rel="external">SOSR 2016</a><br><a href="http://conferences.sigcomm.org/sosr/2017/" target="_blank" rel="external">SOSR 2017</a></p><ul><li>Applications of SDN in home, wireless, cellular, enterprise, data-center, backbone, and transport networks</li><li>Applications of SDN to network management, monitoring, security, Internet of Things (IoT), content-centric networking, etc.</li><li>Virtualized network functions (e.g., firewalls, intrusion detection systems, load balancers, etc.) built or managed using software-defined networks</li><li>Virtualization of SDNs(not in 2015)</li><li>White-box and bare-metal switching</li><li>Novel data-plane architectures for software defined networks</li><li>Programming languages, verification techniques, and testing techniques for SDN</li><li>New SDN control frameworks</li><li>Techniques for improving the security, reliability, performance, and scalability of SDNs</li><li>Experiences deploying SDN technology and applications in operational networks</li><li>Strategies for the incremental deployment of SDN in existing networks</li><li>Distributed SDN control planes for better reliability, security, and performance</li></ul><p>In addition to traditional research papers, we seek papers that present(not in 2015):</p><ul><li>The design and applications of useful SDN tools</li><li>Surveys of important SDN concepts, techniques, and standards</li><li>Technical overviews of larger research projects, production systems, and use cases</li><li>Open-source benchmark suites or measurement data for evaluating SDN systems</li></ul><p><a href="https://www.netsys2015.com/workshops/sdnflex/" target="_blank" rel="external">SDNFLEX 2015</a><br><a href="http://sdnflex.org/" target="_blank" rel="external">SDNFLEX 2017</a><br>Workshop on Software-Defined Networking and Network Function Virtualization for Flexible Network Management<br>SDNFLEX其实是两年一次的NetSys会议的研讨会之一，以下是关于NetSys的介绍：</p><blockquote><p>NetSys is a biennial event that originates from the key scientific conference on networked systems in German-speaking countries KiVS (Kommunikation in Verteilten Systemen) – which was initiated 37 years ago and has international orientation since 2013. NetSys is organized by the special interest group “Communication and Distributed Systems” (KUVS), which is anchored both in the German Computer Science society (Gesellschaft für Informatik (GI)) and in the Information Technology society (Informationstechnische Gesellschaft im VDE (ITG)). It is technically co-sponsored by IEEE Communications Society (ComSoc) and in cooperation with ACM SIGCOMM.  </p></blockquote><p>两届的topics of interest没有变化：</p><ul><li>SDN/NFV architectures, applications, and use cases</li><li>Network monitoring and QoE</li><li>Reliability of virtualized network functions</li><li>SDN/NFV-based service orchestration</li><li>SDN/NFV-based network deployment and management</li><li>Business considerations and economic aspects</li><li>SDN/NFV security</li><li>Theoretical foundations of SDN/NFV networks</li><li>Network Operating Systems and Languages</li><li>SDN in Mobile and Wireless Networks</li><li>Network Service Chaining</li></ul><p>会议网站还为期刊IJNM Special Issue on SDN/NFV刊登了CFP:</p><ul><li>SDN/NFV architectures and applications</li><li>Monitoring and QoE management in virtualized networks</li><li>Advanced content placement in virtualized networks</li><li>Business considerations and economic aspects</li><li>Network Operating Systems and Languages</li><li>SDN in Mobile and Wireless Networks</li><li>SDN/NFV Resource allocation algorithms</li><li>Reliability of virtualized network functions</li><li>SDN/NFV-based service orchestration</li><li>SDN/NFV-based network deployment and Management</li><li>Security Management in SDN/NFV-based systems</li><li>Theoretical foundations of SDN/NFV networks</li><li>Construction and deployment of Service Function Chains</li><li>Fault correlation and diagnosis in virtualized networks</li></ul><p>CoolSDN(全称COntrol, Operation, and appLication in SDN protocols，感觉像是特地凑出来的名字)是会议ICNP的研讨会，参会者主要来自亚洲，欧洲和北美。</p><p><a href="http://success.cse.tamu.edu/CoolSDN2014/" target="_blank" rel="external">CoolSDN 2014</a><br><a href="http://success.cse.tamu.edu/CoolSDN2015/" target="_blank" rel="external">CoolSDN 2015</a><br><a href="http://success.cse.tamu.edu/CoolSDN2016/index.php" target="_blank" rel="external">CoolSDN 2016</a></p><ul><li>SDN Challenges</li><li>SDN Architecture</li><li>Formal Methods in SDN</li><li>SDN Protocol Engineering</li><li>SDN Programming Correctness</li><li>SDN Programming Interfaces (South Bound, North Bound, and East-west Bound)</li><li>SDN Network Operating System</li><li>SDN Data Plane Abstraction</li><li>SDN Network Abstraction and View</li><li>SDN Performance and Reliability</li><li>SDN Protocol Application</li><li>SDN Security</li><li>SDN Survey</li></ul><p>EWSDN也开始的比较早，从2012年便开始了(比HotSDN晚了两个月)，CFP的变动也是十分剧烈，几乎每年都不一样。</p><p><a href="https://www.ewsdn.eu/index.php/EWSDN_2012.html" target="_blank" rel="external">EWSDN 2012</a></p><ul><li>Optical extensions to OpenFlow, SDN</li><li>Wireless integration, characterization of wireless interfaces, flows, handover support</li><li>Evolved packet core, LTE support for OpenFlow</li><li>New controller architectures, Application Programmer’s Interfaces, SDN “north-bound” interfaces</li><li>Higher level SDN abstractions, APIs, object models</li><li>New networking paradigms like Content or Information Centric Networks (CCN/ICN) and their relation with SDN</li><li>Carrier-grade SDN architectures and equipment</li><li>Network Virtualization techniques based on SDN</li><li>Practical experiments on OpenFlow / SDN based testbeds</li><li>Identification of use cases for SDN, SDN related business models</li><li>SDN frameworks and tools, SDN based equipment: controllers, switches, integrated development environment, testing and debugging environment</li></ul><p><a href="https://www.ewsdn.eu/index.php/EWSDN_2013.html" target="_blank" rel="external">EWSDN 2013</a></p><ul><li>Forwarding abstractions, APIs, object models</li><li>Network Function Virtualization and SDN, Network Virtualization techniques based on SDN</li><li>Optical extensions to OpenFlow, SDN</li><li>Wireless integration, characterization of wireless interfaces, flows, handover support</li><li>Evolved packet core, LTE support for OpenFlow</li><li>New controller architectures, Application Programmer’s Interfaces, SDN “north-bound” interfaces</li><li>Interoperation of cloud architectures and SDN</li><li>New switch architectures supporting SDN</li><li>New networking paradigms like Content or Information Centric Networks (CCN/ICN) and their relation with SDN</li><li>Carrier-grade SDN architectures and equipment</li><li>Practical experiments on OpenFlow / SDN based testbeds</li><li>Identification of use cases for SDN, SDN related business models, strategic role of SDN in network evolution</li><li>SDN frameworks and tools, SDN based equipment: controllers, switches, integrated development environment, testing and debugging environment</li></ul><p><a href="https://www.ewsdn.eu/index.php/EWSDN_2014.html" target="_blank" rel="external">EWSDN 2014</a></p><ul><li>Virtualization architectures</li><li>Forwarding abstractions, APIs, object models</li><li>Network Function Virtualization and SDN, network virtualization techniques</li><li>Optical extensions to OpenFlow, SDN</li><li>Wireless integration, characterization of wireless interfaces, flows, handover support</li><li>Evolved packet core, LTE support for OpenFlow</li><li>New controller architectures, APIs and northbound interfaces</li><li>Interoperation of cloud architectures and SDN</li><li>New switch architectures supporting SDN</li><li>New networking paradigms like Information Centric Networks (ICN) and relation to SDN</li><li>Security implications of SDN and security enhancements to SDN, as well as new security services enabled by SDN</li><li>Carrier-grade SDN architectures and equipment</li><li>Practical experiments on SDN/Cloud/OpenFlow</li><li>Testbeds</li><li>Identification of use cases for SDN, SDN-related business models, strategic role of SDN in network evolution</li><li>Regulatory aspects around network virtualization</li><li>SDN frameworks and tools, SDN-based equipment: controllers, switches, integrated development environment, testing and debugging environment.</li><li>Workshop proceedings</li></ul><p><a href="https://www.ewsdn.eu/index.php/EWSDN_2015.html" target="_blank" rel="external">EWSDN 2015</a></p><p>论文链接： <a href="http://ieeexplore.ieee.org/xpl/mostRecentIssue.jsp?punumber=7312774" target="_blank" rel="external">IEEE Xplore - Conference Table of Contents</a></p><p>官方没有提供信息，参考WikiCFP上的内容：<a href="http://www.wikicfp.com/cfp/servlet/event.showcfp?eventid=47908" target="_blank" rel="external">http://www.wikicfp.com/cfp/servlet/event.showcfp?eventid=47908</a></p><p><a href="https://www.ewsdn.eu/" target="_blank" rel="external">EWSDN 2016</a></p><ul><li>Network Virtualization and Slicing techniques.</li><li>Northbound Interfaces.</li><li>Advances in Intent programming.</li><li>New switch architectures and software/hardware implementations supporting SDN.</li><li>Debugging SDNs.</li><li>Deployments of SDN and NFV solutions.</li><li>Network Function Virtualization and SDN, network virtualization techniques.</li><li>Coordinated control of NFV and SDN in one infrastructure.</li><li>Interoperation of cloud architectures and SDN.</li><li>Security applications over, implications of and enhancements to SDN.</li><li>Industry challenges to SDN deployment.<br>网站上没有2017的，最新的CFP待更新。</li></ul><p><a href="http://www.cnsm-conf.org/2014/sdnnfv2014.html" target="_blank" rel="external">ManSDN/NFV 2014</a><br><a href="http://www.cnsm-conf.org/2015/sdnnfv2015.html" target="_blank" rel="external">ManSDN/NFV 2015</a></p><ul><li>Design of architectural building blocks for managing SDN and NFV systems</li><li>SDN and NFV APIs and protocols</li><li>Advances in measurement, management, security, accounting, mobility, and other functions using SDN or NFV systems</li><li>Virtualization of resources, services and functions in SDN and NFV</li><li>Management of telco cloud computing infrastructures</li><li>Efficient deployment of Service Function Chains (SFCs)</li><li>Management of federated SDN/NFV infrastructures</li><li>Dynamic migration of network functions in NFV-based systems</li><li>Efficient network and service monitoring for SDN or NFV</li><li>Resource management for SDN or NFV-based systems</li><li>Automated configurations and repair</li><li>Integration of SDN and NFV solutions</li><li>Distributed SDN/NFV control</li><li>Abstractions for programmable network elements</li><li>Computing and software as a network-centric service</li><li>Information exchange between management layers, systems, and components</li><li>Integrated resource management of network and services</li><li>Virtualization of radio network functions</li><li>Policy management in SDN or NFV systems</li><li>Support for bug free Software Defined Networks</li><li>Results from techno-economic, legal and regulatory studies driving the deployment of SDN and NFV technology</li><li>Experience reports from management in experimental testbeds</li><li>Transitioning existing networks to SDN</li></ul><p>接下来两年的重点开始变化:</p><p><a href="http://www.cnsm-conf.org/2016/sdnnfv2016.html" target="_blank" rel="external">ManSDN/NFV 2016</a><br><a href="http://www.cnsm-conf.org/2017/sdnnfv2017.html" target="_blank" rel="external">ManSDN/NFV 2017</a></p><ul><li>Design of architectural building blocks for managing SDN and NFV systems</li><li>SDN and NFV APIs and protocols</li><li>Advances in measurement, management, security, accounting, mobility, and other functions using SDN or NFV systems</li><li>Virtualization of resources, services and functions in SDN and NFV</li><li>Management of telco cloud computing infrastructures</li><li>Efficient deployment of Service Function Chains (SFCs)</li><li>Management of federated SDN/NFV infrastructures</li><li>Dynamic migration of network functions in NFV-based systems</li><li>Efficient network and service monitoring for SDN or NFV</li><li>Resource management for SDN or NFV-based systems</li><li>Automated configurations and repair</li><li>Integration of SDN and NFV solutions</li><li>Distributed SDN/NFV control</li><li>Abstractions for programmable network elements</li><li>Policy management in SDN or NFV systems</li><li>Support for bug free Software Defined Networks</li><li>Computing and software as a network-centric service</li><li>Information exchange between management layers, systems, and components</li><li>Integrated resource management of network and services</li><li>Virtualization of radio network functions</li><li>Results from techno-economic, legal and regulatory studies driving the deployment of SDN and NFV technology</li><li>Experience reports from management in experimental testbeds</li><li>Transitioning existing networks to SDN</li><li>Deployment of emerging network stacks with network virtualization</li><li>Intent-based networking</li><li>SDN/NFV management in 5G scenarios(2016)</li><li>SDN/NFV management in 5G and wireless networks(2017)</li></ul><p>作为新兴的领域，SDN相关的期刊还很少（前面提到过一个），这里不再整理，研讨会的paper我整理好之后会放在博文中。本文会持续更新跟踪最新的SDN相关的会议情况…</p><p>Journal 收集：</p><ul><li><a href="https://www.journals.elsevier.com/future-generation-computer-systems" target="_blank" rel="external">Future Generation Computer Systems</a></li><li><a href="https://www.journals.elsevier.com/computer-networks" target="_blank" rel="external">Computer Networks</a></li></ul><p>类型收集：</p><ul><li>onference and Workshop Papers</li><li>Journal Articles</li><li>Informal Publications</li><li>Editorship</li><li>Books and Theses</li><li>Parts in Books or Collections</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近整理了SDN相关的会议以及它们的Topics of Interest，希望能够从中看出SDN发展的一些趋势。持续更新…&lt;/p&gt;
    
    </summary>
    
      <category term="Comment" scheme="https://mhxie.me/categories/Comment/"/>
    
    
      <category term="SDN" scheme="https://mhxie.me/tags/SDN/"/>
    
      <category term="Network" scheme="https://mhxie.me/tags/Network/"/>
    
      <category term="workshop" scheme="https://mhxie.me/tags/workshop/"/>
    
      <category term="Paper" scheme="https://mhxie.me/tags/Paper/"/>
    
  </entry>
  
  <entry>
    <title>[译]Twisted Mail Tutorial: Building an SMTP Client from Scratch</title>
    <link href="https://mhxie.me/2016/11/13/%5BTranslation%5DTwisted-Mail-Tutorial-Building-an-SMTP-Client-from-Scratch/"/>
    <id>https://mhxie.me/2016/11/13/[Translation]Twisted-Mail-Tutorial-Building-an-SMTP-Client-from-Scratch/</id>
    <published>2016-11-13T09:21:12.000Z</published>
    <updated>2018-10-08T05:00:20.650Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>This tutorial will walk you through the creation of an extremely simple SMTP client application. By the time the tutorial is complete, you will understand how to create and start a TCP client speaking the SMTP protocol, have it connect to an appropriate mail exchange server, and transmit a message for delivery.  </p><p>For the majority of this tutorial, twistd will be used to launch the application. Near the end we will explore other possibilities for starting a Twisted application. Until then, make sure that you have twistd installed and conveniently accessible for use in running each of the example .tac files.  </p></blockquote><p>教程整理自twitsed的官方文档， <strong>原文有删改</strong> ， <a href="https://twistedmatrix.com/documents/current/mail/tutorial/smtpclient/smtpclient.html" target="_blank" rel="external">原文链接</a></p><p><strong>Caution</strong>：本文较长，建议抽出一段较长的时间边运行代码边读。</p><p>因为时间有限，很多细节没有翻译，有时间一定补上( ̀⌄ ́)</p><p>主要是通过介绍一些及其简单的客户端应用来让我们理解如何创建并启动一个用SMTP协议的TCP客户端，让它能够连接到合适的邮件交换服务器，并能提交用于转发的信息。<br><a id="more"></a></p><h3 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h3><ul><li>已经配置安装好python，这里使用的版本是2.7.12（注意现在twisted对python 3 的支持还不完全）</li><li>安装好twisted，这里使用的版本是16.5.0</li><li>确保电脑上的twistd服务可用（应该会随twisted自动安装）</li></ul><h3 id="启动SMTP服务器"><a href="#启动SMTP服务器" class="headerlink" title="启动SMTP服务器"></a>启动SMTP服务器</h3><p>将下面的代码保存为 <code>email_server.tac</code> ，运行 <code>sudo twistd -ny emailserver.tac</code> 在本地启动服务器，注意sudo不是必须的，因为电脑限制了25端口的开放，所以必须调用最高权限来启动这段代码，你也可以修改其中的25为其他未占用的端口，但注意也要改动之后的SMTP客户端的代码端口为你修改的端口。</p><pre><code># Copyright (c) Twisted Matrix Laboratories.# See LICENSE for details.# You can run this module directly with:#    twistd -ny emailserver.tac&quot;&quot;&quot;A toy email server.&quot;&quot;&quot;from __future__ import print_functionfrom zope.interface import implementerfrom twisted.internet import deferfrom twisted.mail import smtpfrom twisted.mail.imap4 import LOGINCredentials, PLAINCredentialsfrom twisted.cred.checkers import InMemoryUsernamePasswordDatabaseDontUsefrom twisted.cred.portal import IRealmfrom twisted.cred.portal import Portal@implementer(smtp.IMessageDelivery)class ConsoleMessageDelivery:    def receivedHeader(self, helo, origin, recipients):        return &quot;Received: ConsoleMessageDelivery&quot;    def validateFrom(self, helo, origin):        # All addresses are accepted        return origin    def validateTo(self, user):        # Only messages directed to the &quot;console&quot; user are accepted.        if user.dest.local == &quot;console&quot;:            return lambda: ConsoleMessage()        raise smtp.SMTPBadRcpt(user)@implementer(smtp.IMessage)class ConsoleMessage:    def __init__(self):        self.lines = []    def lineReceived(self, line):        self.lines.append(line)    def eomReceived(self):        print(&quot;New message received:&quot;)        print(&quot;\n&quot;.join(self.lines))        self.lines = None        return defer.succeed(None)    def connectionLost(self):        # There was an error, throw away the stored lines        self.lines = Noneclass ConsoleSMTPFactory(smtp.SMTPFactory):    protocol = smtp.ESMTP    def __init__(self, *a, **kw):        smtp.SMTPFactory.__init__(self, *a, **kw)        self.delivery = ConsoleMessageDelivery()    def buildProtocol(self, addr):        p = smtp.SMTPFactory.buildProtocol(self, addr)        p.delivery = self.delivery        p.challengers = {&quot;LOGIN&quot;: LOGINCredentials, &quot;PLAIN&quot;: PLAINCredentials}        return p@implementer(IRealm)class SimpleRealm:    def requestAvatar(self, avatarId, mind, *interfaces):        if smtp.IMessageDelivery in interfaces:            return smtp.IMessageDelivery, ConsoleMessageDelivery(), lambda: None        raise NotImplementedError()def main():    from twisted.application import internet    from twisted.application import service    portal = Portal(SimpleRealm())    checker = InMemoryUsernamePasswordDatabaseDontUse()    checker.addUser(&quot;guest&quot;, &quot;password&quot;)    portal.registerChecker(checker)    a = service.Application(&quot;Console SMTP Server&quot;)    internet.TCPServer(25, ConsoleSMTPFactory(portal)).setServiceParent(a)    return aapplication = main()</code></pre><h3 id="第一个SMTP客户端"><a href="#第一个SMTP客户端" class="headerlink" title="第一个SMTP客户端"></a>第一个SMTP客户端</h3><p>可能的话，创建一个 <code>smtpclient-1.tac</code> 为twistd所使用。</p><p>源代码：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> twisted.<span class="built_in">application</span> import service</div><div class="line"><span class="comment"># The first line of the .tac file imports twisted.application.service , a module</span></div><div class="line"><span class="comment"># which contains many of the basic service classes and helper functions available</span></div><div class="line"><span class="comment"># in Twisted. In particular, we will be using the Application function to create</span></div><div class="line"><span class="comment"># a new application service . An application service simply acts as a central</span></div><div class="line"><span class="comment"># object on which to store certain kinds of deployment configuration.</span></div><div class="line"></div><div class="line"><span class="built_in">application</span> = service.Application(<span class="string">"SMTP Client Tutorial"</span>)</div><div class="line"></div><div class="line"><span class="comment"># The second line of the .tac file creates a new application service and binds</span></div><div class="line"><span class="comment"># it to the local name application . twistd requires this local name in each .tac</span></div><div class="line"><span class="comment"># file it runs. It uses various pieces of configuration on the object to determine</span></div><div class="line"><span class="comment"># its behavior. For example, "SMTP Client Tutorial" will be used as the name of</span></div><div class="line"><span class="comment"># the .tap file into which to serialize application state, should it be necessary</span></div><div class="line"><span class="comment"># to do so.</span></div></pre></td></tr></table></figure><p>运行我们的服务器，这里-n代表以非后台形式运行，-y表示在python源文件里读取applicaiton：</p><pre><code>❯ twistd -ny smtpclient-1.tac2016-11-12T16:55:36+0800 [-] Loading smtpclient-1.tac...2016-11-12T16:55:36+0800 [-] Loaded.2016-11-12T16:55:37+0800 [twisted.scripts._twistd_unix.UnixAppLogger#info] twistd 16.5.0 (/usr/local/opt/python/bin/python2.7 2.7.12) starting up.2016-11-12T16:55:37+0800 [twisted.scripts._twistd_unix.UnixAppLogger#info] reactor class: twisted.internet.selectreactor.SelectReactor.</code></pre><p>正如显示的这样，没有什么多余的动作了，用^C 来结束它：</p><pre><code>^C2016-11-12T15:42:31+0800 [-] Received SIGINT, shutting down.2016-11-12T15:42:31+0800 [-] Main loop terminated.2016-11-12T15:42:31+0800 [twisted.scripts._twistd_unix.UnixAppLogger#info] Server Shut Down.</code></pre><h3 id="第二个SMTP客户端"><a href="#第二个SMTP客户端" class="headerlink" title="第二个SMTP客户端"></a>第二个SMTP客户端</h3><p>第一个客户端并不是十分有趣，它甚至没有建立任何TCP连接，接下来这个 <code>smtpclient-2.tac</code> 会更加接近于那个复杂程度。</p><p>源代码：</p><pre><code>from twisted.application import serviceapplication = service.Application(&quot;SMTP Client Tutorial&quot;)from twisted.application import internetfrom twisted.internet import protocol# twisted.application.internet is another application service module. It provides# services for establishing outgoing connections (as well as creating network# servers, though we are not interested in those parts for the moment).# twisted.internet.protocol provides base implementations of many of the core# Twisted concepts, such as factories and protocols .# The next line of smtpclient-2.tac instantiates a new client factory .smtpClientFactory = protocol.ClientFactory()# Client factories are responsible for constructing protocol instances whenever# connections are established. They may be required to create just one instance,# or many instances if many different connections are established, or they may# never be required to create one at all, if no connection ever manages to be# established.# Now that we have a client factory, we’ll need to hook it up to the network# somehow. The next line of smtpclient-2.tac does just that:smtpClientService = internet.TCPClient(None, None, smtpClientFactory)# We’ll ignore the first two arguments to internet.TCPClient for the moment and# instead focus on the third. TCPClient is one of those application service# classes. It creates TCP connections to a specified address and then uses its# third argument, a client factory , to get a protocol instance . It then# associates the TCP connection with the protocol instance and gets out of the way.smtpClientService.setServiceParent(application)</code></pre><p>我们来试试运行这个客户端：</p><pre><code>❯ twistd -ny smtpclient-2.tac2016-11-12T16:55:57+0800 [-] Loading smtpclient-2.tac...2016-11-12T16:55:57+0800 [-] Loaded.2016-11-12T16:55:58+0800 [twisted.scripts._twistd_unix.UnixAppLogger#info] twistd 16.5.0 (/usr/local/opt/python/bin/python2.7 2.7.12) starting up.2016-11-12T16:55:58+0800 [twisted.scripts._twistd_unix.UnixAppLogger#info] reactor class: twisted.internet.selectreactor.SelectReactor.2016-11-12T16:55:58+0800 [stderr#error] Traceback (most recent call last):2016-11-12T16:55:58+0800 [stderr#error]   File &quot;/usr/local/bin/twistd&quot;, line 11, in &lt;module&gt;2016-11-12T16:55:58+0800 [stderr#error]     sys.exit(run())2016-11-12T16:55:58+0800 [stderr#error]   File &quot;/usr/local/lib/python2.7/site-packages/twisted/scripts/twistd.py&quot;, line 29, in run2016-11-12T16:55:58+0800 [stderr#error]     app.run(runApp, ServerOptions)2016-11-12T16:55:58+0800 [stderr#error]   File &quot;/usr/local/lib/python2.7/site-packages/twisted/application/app.py&quot;, line 648, in run2016-11-12T16:55:58+0800 [stderr#error]     runApp(config)2016-11-12T16:55:58+0800 [stderr#error]   File &quot;/usr/local/lib/python2.7/site-packages/twisted/scripts/twistd.py&quot;, line 25, in runApp2016-11-12T16:55:58+0800 [stderr#error]     _SomeApplicationRunner(config).run()2016-11-12T16:55:58+0800 [stderr#error]   File &quot;/usr/local/lib/python2.7/site-packages/twisted/application/app.py&quot;, line 383, in run2016-11-12T16:55:58+0800 [stderr#error]     self.postApplication()2016-11-12T16:55:58+0800 [stderr#error]   File &quot;/usr/local/lib/python2.7/site-packages/twisted/scripts/_twistd_unix.py&quot;, line 248, in postApplication2016-11-12T16:55:58+0800 [stderr#error]     self.startApplication(self.application)2016-11-12T16:55:58+0800 [stderr#error]   File &quot;/usr/local/lib/python2.7/site-packages/twisted/scripts/_twistd_unix.py&quot;, line 444, in startApplication2016-11-12T16:55:58+0800 [stderr#error]     app.startApplication(application, not self.config[&apos;no_save&apos;])2016-11-12T16:55:58+0800 [stderr#error]   File &quot;/usr/local/lib/python2.7/site-packages/twisted/application/app.py&quot;, line 664, in startApplication2016-11-12T16:55:58+0800 [stderr#error]     service.IService(application).startService()2016-11-12T16:55:58+0800 [stderr#error]   File &quot;/usr/local/lib/python2.7/site-packages/twisted/application/service.py&quot;, line 283, in startService2016-11-12T16:55:58+0800 [stderr#error]     service.startService()2016-11-12T16:55:58+0800 [stderr#error]   File &quot;/usr/local/lib/python2.7/site-packages/twisted/application/internet.py&quot;, line 177, in startService2016-11-12T16:55:58+0800 [stderr#error]     self._connection = self._getConnection()2016-11-12T16:55:58+0800 [stderr#error]   File &quot;/usr/local/lib/python2.7/site-packages/twisted/application/internet.py&quot;, line 195, in _getConnection2016-11-12T16:55:58+0800 [stderr#error]     &apos;connect%s&apos; % (self.method,))(*self.args, **self.kwargs)2016-11-12T16:55:58+0800 [stderr#error]   File &quot;/usr/local/lib/python2.7/site-packages/twisted/internet/posixbase.py&quot;, line 482, in connectTCP2016-11-12T16:55:58+0800 [stderr#error]     c = tcp.Connector(host, port, factory, timeout, bindAddress, self)2016-11-12T16:55:58+0800 [stderr#error]   File &quot;/usr/local/lib/python2.7/site-packages/twisted/internet/tcp.py&quot;, line 1164, in __init__2016-11-12T16:55:58+0800 [stderr#error]     if abstract.isIPv6Address(host):2016-11-12T16:55:58+0800 [stderr#error]   File &quot;/usr/local/lib/python2.7/site-packages/twisted/internet/abstract.py&quot;, line 522, in isIPv6Address2016-11-12T16:55:58+0800 [stderr#error]     if &apos;%&apos; in addr:2016-11-12T16:55:58+0800 [stderr#error] TypeError: argument of type &apos;NoneType&apos; is not iterable</code></pre><p>发生了什么？看来我们忽略掉的那两个参数还挺重要的。</p><h3 id="第三个SMTP客户端"><a href="#第三个SMTP客户端" class="headerlink" title="第三个SMTP客户端"></a>第三个SMTP客户端</h3><p>我们给前面两个参数填上localhost和25（SMTP知名端口号）。</p><pre><code>smtpClientService = internet.TCPClient(&apos;localhost&apos;, 25, smtpClientFactory)</code></pre><p>再次尝试运行：</p><pre><code>❯ twistd -ny smtpclient-3.tac2016-11-12T18:28:52+0800 [-] Loading smtpclient-3.tac...2016-11-12T18:28:52+0800 [-] Loaded.2016-11-12T18:28:52+0800 [twisted.scripts._twistd_unix.UnixAppLogger#info] twistd 16.5.0 (/usr/local/opt/python/bin/python2.7 2.7.12) starting up.2016-11-12T18:28:52+0800 [twisted.scripts._twistd_unix.UnixAppLogger#info] reactor class: twisted.internet.selectreactor.SelectReactor.2016-11-12T18:28:52+0800 [twisted.internet.protocol.ClientFactory#info] Starting factory &lt;twisted.internet.protocol.ClientFactory instance at 0x11087f908&gt;2016-11-12T18:28:52+0800 [Uninitialized] Unhandled Error    Traceback (most recent call last):      File &quot;/usr/local/lib/python2.7/site-packages/twisted/python/log.py&quot;, line 101, in callWithLogger        return callWithContext({&quot;system&quot;: lp}, func, *args, **kw)      File &quot;/usr/local/lib/python2.7/site-packages/twisted/python/log.py&quot;, line 84, in callWithContext        return context.call({ILogContext: newCtx}, func, *args, **kw)      File &quot;/usr/local/lib/python2.7/site-packages/twisted/python/context.py&quot;, line 118, in callWithContext        return self.currentContext().callWithContext(ctx, func, *args, **kw)      File &quot;/usr/local/lib/python2.7/site-packages/twisted/python/context.py&quot;, line 81, in callWithContext        return func(*args,**kw)    --- &lt;exception caught here&gt; ---      File &quot;/usr/local/lib/python2.7/site-packages/twisted/internet/selectreactor.py&quot;, line 149, in _doReadOrWrite        why = getattr(selectable, method)()      File &quot;/usr/local/lib/python2.7/site-packages/twisted/internet/tcp.py&quot;, line 586, in doConnect        self._connectDone()      File &quot;/usr/local/lib/python2.7/site-packages/twisted/internet/tcp.py&quot;, line 600, in _connectDone        self.protocol = self.connector.buildProtocol(self.getPeer())      File &quot;/usr/local/lib/python2.7/site-packages/twisted/internet/base.py&quot;, line 1074, in buildProtocol        return self.factory.buildProtocol(addr)      File &quot;/usr/local/lib/python2.7/site-packages/twisted/internet/protocol.py&quot;, line 131, in buildProtocol        p = self.protocol()    exceptions.TypeError: &apos;NoneType&apos; object is not callable2016-11-12T18:28:52+0800 [twisted.internet.protocol.ClientFactory#info] Stopping factory &lt;twisted.internet.protocol.ClientFactory instance at 0x11087f908&gt;</code></pre><p>看来还是有问题，不过这一次是因为我们没有明确protocol类给factory用造成的，让我们来看看第四个版本。</p><h3 id="第四个SMTP客户端"><a href="#第四个SMTP客户端" class="headerlink" title="第四个SMTP客户端"></a>第四个SMTP客户端</h3><p>因为我们没有给客户端factory的protocol实行设定一个正确的值，我们无法成功运行上一个例子。ClientFactory.buildProtocol是一个负责创建一个protocol实例的方法，我们这里暂且使用protocol的基类来完成修改。</p><pre><code>from twisted.application import serviceapplication = service.Application(&quot;SMTP Client Tutorial&quot;)from twisted.application import internetfrom twisted.internet import protocolsmtpClientFactory = protocol.ClientFactory()smtpClientFactory.protocol = protocol.ProtocolsmtpClientService = internet.TCPClient(&apos;localhost&apos;, 25, smtpClientFactory)smtpClientService.setServiceParent(application)</code></pre><p>再次运行：</p><pre><code>❯ twistd -ny smtpclient-4.tac2016-11-12T18:46:08+0800 [-] Loading smtpclient-4.tac...2016-11-12T18:46:08+0800 [-] Loaded.2016-11-12T18:46:08+0800 [twisted.scripts._twistd_unix.UnixAppLogger#info] twistd 16.5.0 (/usr/local/opt/python/bin/python2.7 2.7.12) starting up.2016-11-12T18:46:08+0800 [twisted.scripts._twistd_unix.UnixAppLogger#info] reactor class: twisted.internet.selectreactor.SelectReactor.2016-11-12T18:46:08+0800 [twisted.internet.protocol.ClientFactory#info] Starting factory &lt;twisted.internet.protocol.ClientFactory instance at 0x109a3e908&gt;^C2016-11-12T18:46:33+0800 [-] Received SIGINT, shutting down.2016-11-12T18:46:33+0800 [twisted.internet.protocol.ClientFactory#info] Stopping factory &lt;twisted.internet.protocol.ClientFactory instance at 0x109a3e908&gt;2016-11-12T18:46:33+0800 [-] Main loop terminated.2016-11-12T18:46:33+0800 [twisted.scripts._twistd_unix.UnixAppLogger#info] Server Shut Down.</code></pre><p>对于传统UNIX网络服务熟悉的人，twisted.internet.protocol其实等价于discard服务——它将永远不会制造任何输出并且丢弃它所有的输入，可以说毫无用处。</p><h3 id="第五个SMTP客户端"><a href="#第五个SMTP客户端" class="headerlink" title="第五个SMTP客户端"></a>第五个SMTP客户端</h3><p>在这个例子中，我们将第一次使用Twisted的SMTP协议实现。我们将作出明显的改变，仅仅是将 twisted.internet.protocol.Protocol换成twisted.mail.smtp.ESMTPClient，不用担心ESMTP中的E，它告诉我们只是使用一个更新版本的SMTP协议。虽然Twisted中存在SMTPClient，但是我们没有理由去使用它。</p><pre><code>from twisted.application import serviceapplication = service.Application(&quot;SMTP Client Tutorial&quot;)from twisted.application import internetfrom twisted.internet import protocolsmtpClientFactory = protocol.ClientFactory()from twisted.mail import smtpsmtpClientFactory.protocol = smtp.ESMTPClientsmtpClientService = internet.TCPClient(&apos;localhost&apos;, 25, smtpClientFactory)smtpClientService.setServiceParent(application)</code></pre><p>运行：</p><pre><code>❯ twistd -ny smtpclient-5.tac2016-11-12T18:53:19+0800 [-] Loading smtpclient-5.tac...2016-11-12T18:53:19+0800 [-] Loaded.2016-11-12T18:53:19+0800 [twisted.scripts._twistd_unix.UnixAppLogger#info] twistd 16.5.0 (/usr/local/opt/python/bin/python2.7 2.7.12) starting up.2016-11-12T18:53:19+0800 [twisted.scripts._twistd_unix.UnixAppLogger#info] reactor class: twisted.internet.selectreactor.SelectReactor.2016-11-12T18:53:19+0800 [twisted.internet.protocol.ClientFactory#info] Starting factory &lt;twisted.internet.protocol.ClientFactory instance at 0x110622908&gt;2016-11-12T18:53:19+0800 [Uninitialized] Unhandled Error    Traceback (most recent call last):      File &quot;/usr/local/lib/python2.7/site-packages/twisted/python/log.py&quot;, line 101, in callWithLogger        return callWithContext({&quot;system&quot;: lp}, func, *args, **kw)      File &quot;/usr/local/lib/python2.7/site-packages/twisted/python/log.py&quot;, line 84, in callWithContext        return context.call({ILogContext: newCtx}, func, *args, **kw)      File &quot;/usr/local/lib/python2.7/site-packages/twisted/python/context.py&quot;, line 118, in callWithContext        return self.currentContext().callWithContext(ctx, func, *args, **kw)      File &quot;/usr/local/lib/python2.7/site-packages/twisted/python/context.py&quot;, line 81, in callWithContext        return func(*args,**kw)    --- &lt;exception caught here&gt; ---      File &quot;/usr/local/lib/python2.7/site-packages/twisted/internet/selectreactor.py&quot;, line 149, in _doReadOrWrite        why = getattr(selectable, method)()      File &quot;/usr/local/lib/python2.7/site-packages/twisted/internet/tcp.py&quot;, line 586, in doConnect        self._connectDone()      File &quot;/usr/local/lib/python2.7/site-packages/twisted/internet/tcp.py&quot;, line 600, in _connectDone        self.protocol = self.connector.buildProtocol(self.getPeer())      File &quot;/usr/local/lib/python2.7/site-packages/twisted/internet/base.py&quot;, line 1074, in buildProtocol        return self.factory.buildProtocol(addr)      File &quot;/usr/local/lib/python2.7/site-packages/twisted/internet/protocol.py&quot;, line 131, in buildProtocol        p = self.protocol()    exceptions.TypeError: __init__() takes at least 2 arguments (1 given)2016-11-12T18:53:19+0800 [twisted.internet.protocol.ClientFactory#info] Stopping factory &lt;twisted.internet.protocol.ClientFactory instance at 0x110622908&gt;</code></pre><p>看来还是有问题，这次的原因在于默认的buildProtocol在实例化protocol时没有参数，但是ESMTPClient想要至少一个参数，在下一个版本里，我们将通过重载buildProtocol函数来解决问题。</p><h3 id="第六个SMTP客户端"><a href="#第六个SMTP客户端" class="headerlink" title="第六个SMTP客户端"></a>第六个SMTP客户端</h3><p>代码：</p><pre><code>from twisted.application import serviceapplication = service.Application(&quot;SMTP Client Tutorial&quot;)from twisted.application import internetfrom twisted.internet import protocolfrom twisted.mail import smtpclass SMTPClientFactory(protocol.ClientFactory):    protocol = smtp.ESMTPClient    def buildProtocol(self, addr):        return self.protocol(secret=None, identity=&apos;example.com&apos;)# The overridden method does almost the same thing as the base implementation:# the only change is that it passes values for two arguments to# twisted.mail.smtp.ESMTPClient ‘s initializer. The secret argument is used for# SMTP authentication (which we will not attempt yet). The identity argument is# used as a to identify ourselves Another minor change to note is that the# protocol attribute is now defined in the class definition, rather than tacked# onto an instance after one is created. This means it is a class attribute,# rather than an instance attribute, now, which makes no difference as far as# this example is concerned. There are circumstances in which the difference is# important: be sure you understand the implications of each approach when# creating your own factories.# One other change is required: instead of instantiating# twisted.internet.protocol.ClientFactory , we will now instantiate# SMTPClientFactory :smtpClientFactory = SMTPClientFactory()smtpClientService = internet.TCPClient(&apos;localhost&apos;, 25, smtpClientFactory)smtpClientService.setServiceParent(application)</code></pre><p>运行：</p><pre><code>❯ twistd -ny smtpclient-6.tac2016-11-12T19:53:54+0800 [-] Loading smtpclient-6.tac...2016-11-12T19:53:54+0800 [-] Loaded.2016-11-12T19:53:54+0800 [twisted.scripts._twistd_unix.UnixAppLogger#info] twistd 16.5.0 (/usr/local/opt/python/bin/python2.7 2.7.12) starting up.2016-11-12T19:53:54+0800 [twisted.scripts._twistd_unix.UnixAppLogger#info] reactor class: twisted.internet.selectreactor.SelectReactor.2016-11-12T19:53:54+0800 [__builtin__.SMTPClientFactory#info] Starting factory &lt;__builtin__.SMTPClientFactory instance at 0x1011ed3b0&gt;2016-11-12T19:53:54+0800 [ESMTPClient,client] Unhandled Error    Traceback (most recent call last):      File &quot;/usr/local/lib/python2.7/site-packages/twisted/python/log.py&quot;, line 101, in callWithLogger        return callWithContext({&quot;system&quot;: lp}, func, *args, **kw)      File &quot;/usr/local/lib/python2.7/site-packages/twisted/python/log.py&quot;, line 84, in callWithContext        return context.call({ILogContext: newCtx}, func, *args, **kw)      File &quot;/usr/local/lib/python2.7/site-packages/twisted/python/context.py&quot;, line 118, in callWithContext        return self.currentContext().callWithContext(ctx, func, *args, **kw)      File &quot;/usr/local/lib/python2.7/site-packages/twisted/python/context.py&quot;, line 81, in callWithContext        return func(*args,**kw)    --- &lt;exception caught here&gt; ---      File &quot;/usr/local/lib/python2.7/site-packages/twisted/internet/selectreactor.py&quot;, line 149, in _doReadOrWrite        why = getattr(selectable, method)()      File &quot;/usr/local/lib/python2.7/site-packages/twisted/internet/tcp.py&quot;, line 208, in doRead        return self._dataReceived(data)      File &quot;/usr/local/lib/python2.7/site-packages/twisted/internet/tcp.py&quot;, line 214, in _dataReceived        rval = self.protocol.dataReceived(data)      File &quot;/usr/local/lib/python2.7/site-packages/twisted/protocols/basic.py&quot;, line 571, in dataReceived        why = self.lineReceived(line)      File &quot;/usr/local/lib/python2.7/site-packages/twisted/mail/smtp.py&quot;, line 913, in lineReceived        why = self._okresponse(self.code,&apos;\n&apos;.join(self.resp))      File &quot;/usr/local/lib/python2.7/site-packages/twisted/mail/smtp.py&quot;, line 1350, in esmtpState_serverConfig        self.tryTLS(code, resp, items)      File &quot;/usr/local/lib/python2.7/site-packages/twisted/mail/smtp.py&quot;, line 1395, in tryTLS        self.authenticate(code, resp, items)      File &quot;/usr/local/lib/python2.7/site-packages/twisted/mail/smtp.py&quot;, line 1462, in authenticate        self.smtpState_from(code, resp)      File &quot;/usr/local/lib/python2.7/site-packages/twisted/mail/smtp.py&quot;, line 940, in smtpState_from        self._from = self.getMailFrom()      File &quot;/usr/local/lib/python2.7/site-packages/twisted/mail/smtp.py&quot;, line 1035, in getMailFrom        raise NotImplementedError    exceptions.NotImplementedError:2016-11-12T19:53:54+0800 [__builtin__.SMTPClientFactory#info] Stopping factory &lt;__builtin__.SMTPClientFactory instance at 0x1011ed3b0&gt;</code></pre><blockquote><p>What we have accomplished with this iteration of the example is to navigate far enough into an SMTP transaction that Twisted is now interested in calling back to application-level code to determine what its next step should be. In the next example, we’ll see how to provide that information to it.<br>（这句有点长，怕翻译的不到位……）</p></blockquote><h3 id="第七个SMTP客户端"><a href="#第七个SMTP客户端" class="headerlink" title="第七个SMTP客户端"></a>第七个SMTP客户端</h3><p>这个版本时我们的SMTP客户端第一次真正包括了数据传递。</p><p>为了简洁性考虑，信息被定义为新类的一部分。在实际可用于发送邮件的客户端，信息数据可能会从文件系统、数据库，还可能由用户输入中引入。</p><p>在这里我们在类里定义了三个属性 <code>(mailFrom , mailTo , and mailData )</code></p><pre><code>from __future__ import print_functionimport StringIOfrom twisted.application import serviceapplication = service.Application(&quot;SMTP Client Tutorial&quot;)from twisted.application import internetfrom twisted.internet import protocolfrom twisted.mail import smtpclass SMTPTutorialClient(smtp.ESMTPClient):    mailFrom = &quot;tutorial_sender@example.com&quot;    mailTo = &quot;tutorial_recipient@example.net&quot;    mailData = &apos;&apos;&apos;\Date: Fri, 6 Feb 2004 10:14:39 -0800From: Tutorial Guy &lt;tutorial_sender@example.com&gt;To: Tutorial Gal &lt;tutorial_recipient@example.net&gt;Subject: Tutorate!Hello, how are you, goodbye.&apos;&apos;&apos;    def getMailFrom(self):        result = self.mailFrom        self.mailFrom = None        return result    def getMailTo(self):        return [self.mailTo]    def getMailData(self):        return StringIO.StringIO(self.mailData)    def sentMail(self, code, resp, numOk, addresses, log):        print(&apos;Sent&apos;, numOk, &apos;messages&apos;)class SMTPClientFactory(protocol.ClientFactory):    protocol = SMTPTutorialClient    def buildProtocol(self, addr):        return self.protocol(secret=None, identity=&apos;example.com&apos;)smtpClientFactory = SMTPClientFactory()smtpClientService = internet.TCPClient(&apos;localhost&apos;, 25, smtpClientFactory)smtpClientService.setServiceParent(application)</code></pre><p>我们来剖析一下其中的四个函数：</p><ul><li><code>def getMailFrom(self):</code> 这个方法用于确定 <code>reverse-path</code>  ——也被称作发件地址。这个值被用于SMTP中的 <code>MAIL</code> 命令。这个方法必须返回符合 RFC 2821 定义的一个 <code>reverse-path</code> 。简单的说，就是它可以是i 个像”alice@example.com”这样的字符串。注意只有一个发件地址被SMTP协议所允许；</li><li><code>def getMailTo(self):</code> 和上一个方法差不多，返回一个或多个RFC 2821定义的 <code>forward-path</code> —— 转发地址，注意它必须包括至少一个地址，即使只有一个，它也将是一个列表（感觉这里好啰嗦）；</li><li><code>def getMailData(self):</code> 这个也很简单，它将会返回一个包含信息内容的文件或者类文件对象。在这里，它将返回一个StringIO因为我们已经有一个包括信息的字符窜了。假使文件内容包括多行（正如邮件通常的样子），行间应该由 <code>\n</code> 来划分（正如我们经常以“rt”模式打开文本文件）：必要的newline会由 <code>SMTPClient</code> 自动转换；</li><li><p><code>def sentMail(self, code, resp, numOk, addresses, log):</code> 这个方法和邮件发送没有太大关系，是用给twisted来提供信息传递成功与失败信息的；其中 <code>code</code> 是最终命令返回的状态码：</p><blockquote><p>For successful transactions, it will be 250. For transient failures (those which should be retried), it will be between 400 and 499, inclusive. For permanent failures (this which will never work, no matter how many times you retry them), it will be between 500 and 599.  </p></blockquote><p>  ❯ twistd -ny smtpclient-7.tac<br>  2016-11-12T20:06:32+0800 [-] Loading smtpclient-7.tac…<br>  2016-11-12T20:06:32+0800 [-] Loaded.<br>  2016-11-12T20:06:32+0800 [twisted.scripts._twistd_unix.UnixAppLogger#info] twistd 16.5.0 (/usr/local/opt/python/bin/python2.7 2.7.12) starting up.<br>  2016-11-12T20:06:32+0800 [twisted.scripts._twistd_unix.UnixAppLogger#info] reactor class: twisted.internet.selectreactor.SelectReactor.<br>  2016-11-12T20:06:32+0800 [<strong>builtin</strong>.SMTPClientFactory#info] Starting factory <__builtin__.smtpclientfactory instance="" at="" 0x10c04fa70=""><br>  2016-11-12T20:06:32+0800 [stdout#info] Sent 0 messages<br>  2016-11-12T20:06:32+0800 [<strong>builtin</strong>.SMTPClientFactory#info] Stopping factory <__builtin__.smtpclientfactory instance="" at="" 0x10c04fa70=""></__builtin__.smtpclientfactory></__builtin__.smtpclientfactory></p></li></ul><h3 id="第八个SMTP客户端"><a href="#第八个SMTP客户端" class="headerlink" title="第八个SMTP客户端"></a>第八个SMTP客户端</h3><p>这个版本就添加了两行代码，避免了每次发送完邮件后都要输入^C 的尴尬……</p><pre><code>from __future__ import print_functionimport StringIOfrom twisted.application import serviceapplication = service.Application(&quot;SMTP Client Tutorial&quot;)from twisted.application import internetfrom twisted.internet import protocolfrom twisted.mail import smtpclass SMTPTutorialClient(smtp.ESMTPClient):    mailFrom = &quot;tutorial_sender@example.com&quot;    # mailTo = &quot;tutorial_recipient@example.net&quot;    mailTo = &quot;console@example.net&quot;    mailData = &apos;&apos;&apos;\Date: Fri, 6 Feb 2004 10:14:39 -0800From: Tutorial Guy &lt;tutorial_sender@example.com&gt;To: Tutorial Gal &lt;tutorial_recipient@example.net&gt;Subject: Tutorate!Hello, how are you, goodbye.&apos;&apos;&apos;    def getMailFrom(self):        result = self.mailFrom        self.mailFrom = None        return result    def getMailTo(self):        return [self.mailTo]    def getMailData(self):        return StringIO.StringIO(self.mailData)    def sentMail(self, code, resp, numOk, addresses, log):        print(&apos;Sent&apos;, numOk, &apos;messages&apos;)        from twisted.internet import reactor        reactor.stop()class SMTPClientFactory(protocol.ClientFactory):    protocol = SMTPTutorialClient    def buildProtocol(self, addr):        return self.protocol(secret=None, identity=&apos;example.com&apos;)smtpClientFactory = SMTPClientFactory()smtpClientService = internet.TCPClient(&apos;localhost&apos;, 25, smtpClientFactory)smtpClientService.setServiceParent(application)</code></pre><p>stop作为reactor的一个方法，是退出twisted事件循环的重要函数。（关于对twisted异步编程的机制，在过段时间对twisted有了更深入的理解后会总结成一篇博文。）</p><p>运行：</p><pre><code>❯ twistd -ny smtpclient-8.tac2016-11-12T20:55:58+0800 [-] Loading smtpclient-8.tac...2016-11-12T20:55:58+0800 [-] Loaded.2016-11-12T20:55:58+0800 [twisted.scripts._twistd_unix.UnixAppLogger#info] twistd 16.5.0 (/usr/local/opt/python/bin/python2.7 2.7.12) starting up.2016-11-12T20:55:58+0800 [twisted.scripts._twistd_unix.UnixAppLogger#info] reactor class: twisted.internet.selectreactor.SelectReactor.2016-11-12T20:55:58+0800 [__builtin__.SMTPClientFactory#info] Starting factory &lt;__builtin__.SMTPClientFactory instance at 0x10213ca70&gt;2016-11-12T20:55:58+0800 [stdout#info] Sent 0 messages2016-11-12T20:55:58+0800 [__builtin__.SMTPClientFactory#info] Stopping factory &lt;__builtin__.SMTPClientFactory instance at 0x10213ca70&gt;2016-11-12T20:55:58+0800 [-] Main loop terminated.2016-11-12T20:55:58+0800 [twisted.scripts._twistd_unix.UnixAppLogger#info] Server Shut Down.</code></pre><h3 id="第九个SMTP客户端"><a href="#第九个SMTP客户端" class="headerlink" title="第九个SMTP客户端"></a>第九个SMTP客户端</h3><p>还存在一个遗留任务让这个tutorial SMTP变完整：相对总是通过知名主机寄送邮件，我们还会查询邮件交换服务器来寻找收件人的地址并且尝试递交信息给那个主机。</p><p>在这个版本，我们先是通过定义一个函数来完成这个特性</p><pre><code>def getMailExchange(host):    return &apos;localhost&apos;</code></pre><p>很明显这并没有返回正确的邮件交换主机（实际上，它返回我们现在一直使用的主机），但是它给出了决定连接哪个主机的逻辑。我们用它来构造新的TCPClient服务：</p><pre><code>smtpClientService = internet.TCPClient(    getMailExchange(&apos;example.net&apos;), 25, smtpClientFactory)</code></pre><p>下个版本我们会扩充 <code>getMailExchange</code> 的定义。</p><h3 id="第十个SMTP客户端"><a href="#第十个SMTP客户端" class="headerlink" title="第十个SMTP客户端"></a>第十个SMTP客户端</h3><p>对一个特定的域名确定一个邮件交换主机需要包括网络交通（特别的，一些DNS请求）。则可能要花一个非常长的时间，所以我们介绍 <code>Deferred</code> 来表示 <code>getMailExchange</code> 的返回结果，修改函数为：</p><pre><code>def getMailExchange(host):    return defer.succeed(&apos;localhost&apos;)</code></pre><p><code>defer.succeed</code> 用已经存在的结果创建一个新的 <code>Deferred</code> 对象，现在我需要调整TCPClient来构造能够期望并且恰当处理这个 <code>Deferred</code> 代码。</p><pre><code>def cbMailExchange(exchange):    smtpClientFactory = SMTPClientFactory()    smtpClientService = internet.TCPClient(exchange, 25, smtpClientFactory)    smtpClientService.setServiceParent(application)getMailExchange(&apos;example.net&apos;).addCallback(cbMailExchange)</code></pre><p>深入了解 <code>Deferred</code> 已经超出了本文档的范畴，访问这里获得更多信息 <a href="https://twistedmatrix.com/documents/current/core/howto/defer.html" target="_blank" rel="external">Deferred Reference — Twisted 16.5.0 documentation</a></p><h3 id="第十一个SMTP客户端"><a href="#第十一个SMTP客户端" class="headerlink" title="第十一个SMTP客户端"></a>第十一个SMTP客户端</h3><p>我们已经准备好对邮件交换的查询。现在我们将defer换成真正的查找函数—— <code>twisted.mail.relaymanager.MXCalculator</code></p><pre><code>def getMailExchange(host):    def cbMX(mxRecord):        return str(mxRecord.name)    return relaymanager.MXCalculator().getMX(host).addCallback(cbMX)</code></pre><p>因为getMX返回Record_MX对象而不是string对象，在返回之前我们再多做一些预处理。现在我们完成了这个tutorial  SMTP客户端，它能够：</p><ul><li>look up the mail exchange host for the recipient domain</li><li>connect to it</li><li>complete an SMTP transaction</li><li>report its results</li><li>finally shut down the reacto</li></ul><p>最终版本：</p><pre><code>from __future__ import print_functionimport StringIOfrom twisted.application import serviceapplication = service.Application(&quot;SMTP Client Tutorial&quot;)from twisted.application import internetfrom twisted.internet import protocolfrom twisted.internet import deferfrom twisted.mail import smtp, relaymanagerclass SMTPTutorialClient(smtp.ESMTPClient):    mailFrom = &quot;tutorial_sender@example.com&quot;    mailTo = &quot;tutorial_recipient@example.net&quot;    mailData = &apos;&apos;&apos;\Date: Fri, 6 Feb 2004 10:14:39 -0800From: Tutorial Guy &lt;tutorial_sender@example.com&gt;To: Tutorial Gal &lt;tutorial_recipient@example.net&gt;Subject: Tutorate!Hello, how are you, goodbye.&apos;&apos;&apos;    def getMailFrom(self):        result = self.mailFrom        self.mailFrom = None        return result    def getMailTo(self):        return [self.mailTo]    def getMailData(self):        return StringIO.StringIO(self.mailData)    def sentMail(self, code, resp, numOk, addresses, log):        print(&apos;Sent&apos;, numOk, &apos;messages&apos;)        from twisted.internet import reactor        reactor.stop()class SMTPClientFactory(protocol.ClientFactory):    protocol = SMTPTutorialClient    def buildProtocol(self, addr):        return self.protocol(secret=None, identity=&apos;example.com&apos;)def getMailExchange(host):    def cbMX(mxRecord):        return str(mxRecord.name)    return relaymanager.MXCalculator().getMX(host).addCallback(cbMX)def cbMailExchange(exchange):    smtpClientFactory = SMTPClientFactory()    smtpClientService = internet.TCPClient(exchange, 25, smtpClientFactory)    smtpClientService.setServiceParent(application)getMailExchange(&apos;example.net&apos;).addCallback(cbMailExchange)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;This tutorial will walk you through the creation of an extremely simple SMTP client application. By the time the tutorial is complete, you will understand how to create and start a TCP client speaking the SMTP protocol, have it connect to an appropriate mail exchange server, and transmit a message for delivery.  &lt;/p&gt;
&lt;p&gt;For the majority of this tutorial, twistd will be used to launch the application. Near the end we will explore other possibilities for starting a Twisted application. Until then, make sure that you have twistd installed and conveniently accessible for use in running each of the example .tac files.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;教程整理自twitsed的官方文档， &lt;strong&gt;原文有删改&lt;/strong&gt; ， &lt;a href=&quot;https://twistedmatrix.com/documents/current/mail/tutorial/smtpclient/smtpclient.html&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Caution&lt;/strong&gt;：本文较长，建议抽出一段较长的时间边运行代码边读。&lt;/p&gt;
&lt;p&gt;因为时间有限，很多细节没有翻译，有时间一定补上( ̀⌄ ́)&lt;/p&gt;
&lt;p&gt;主要是通过介绍一些及其简单的客户端应用来让我们理解如何创建并启动一个用SMTP协议的TCP客户端，让它能够连接到合适的邮件交换服务器，并能提交用于转发的信息。&lt;br&gt;
    
    </summary>
    
      <category term="Practice" scheme="https://mhxie.me/categories/Practice/"/>
    
    
      <category term="Network" scheme="https://mhxie.me/tags/Network/"/>
    
      <category term="twisted" scheme="https://mhxie.me/tags/twisted/"/>
    
      <category term="python" scheme="https://mhxie.me/tags/python/"/>
    
      <category term="TLDR" scheme="https://mhxie.me/tags/TLDR/"/>
    
  </entry>
  
  <entry>
    <title>【Mac】Terminal改造小记</title>
    <link href="https://mhxie.me/2016/09/21/Mac%20Terminal%20Log/"/>
    <id>https://mhxie.me/2016/09/21/Mac Terminal Log/</id>
    <published>2016-09-21T09:35:22.000Z</published>
    <updated>2018-10-08T05:01:15.154Z</updated>
    
    <content type="html"><![CDATA[<p>先上主要配置，想要自己折腾的同学自己可以行动起来了。</p><p>配置推荐：<strong>HyperTerm</strong>(<code>hyperterm-snazzy</code>+ <code>hyperpower</code> + <code>hyperpower-plus</code> + <code>hyperline</code>)+<strong>oh-my-zsh</strong>(<code>pure</code>+<code>git</code>+<code>autojump</code>+<code>osx</code>+<code>zsh-syntax-highlighting</code>+<code>zsh-wakatime</code>)+<strong>Tmux</strong></p><p>这里是显示效果：</p><p><img src="http://7xkwu7.com1.z0.glb.clouddn.com/HyperTerm.png" alt=""></p><a id="more"></a><p>电脑信息的显示用的命令<code>archey</code>，这样每次启动zsh时就能了解现在系统的大致情况了（好吧，然并软）。用<code>brew install archey</code>后直接在<code>~/.zshrc</code>加一行<code>archey</code>即可。</p><h2 id="HyperTerm配置"><a href="#HyperTerm配置" class="headerlink" title="HyperTerm配置"></a>HyperTerm配置</h2><p>HyperTerm是基于JS/HTML/CSS写的terminal，所以效果各种狂拽炫酷吊炸天，可惜还不够稳定，我认为做到类似的像编辑器中的atom那样就差不多了，但这个项目估计也没这么大号召力…</p><p>也没多折腾，就在配置的plugins里加了几个有(zhuang)用(bi)的插件。</p><ul><li>编辑<code>/Users/yourname/.hyperterm.js</code></li><li>在<code>config</code>里修改默认字体为16</li><li>在<code>config</code>里加入windowSize: ‘[100, 30]’</li><li>我的<code>plugins</code>栏加入<code>hyperterm-snazzy</code>, <code>hyperpower</code>, <code>hyperpower-plus</code>, <code>hyperline</code>，第一个是主题，第二个让输入带特技，第三个…让输入更震撼！！！第四个就是底下的状态栏，各位已经看到了。</li></ul><p>其实只是配置这些还达不到图中的效果，还要配置zsh的主题和一些命令高亮</p><p>好嘛，配置的挺好看，最后我还是用回了terminal，HyperTerm还是不够稳定，也不支持我的一些像Go2Shell这样的小插件，对我这台破电脑也不大友好（各位看看CPU利用率）…</p><p>好在zsh和Tmux配置好了就可以到处跑了，给自带终端加个不错的主题后，我们就把终端的选择先放一边吧。<br>放上我的主题</p><h2 id="zsh配置小记"><a href="#zsh配置小记" class="headerlink" title="zsh配置小记"></a>zsh配置小记</h2><p>要用zsh怎么能不装oh-my-zsh呢（其实也就是因为它zsh才火起来的）？</p><ul><li>wget <a href="https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh" target="_blank" rel="external">https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh</a> -O - | sh 自动安装</li><li>在<code>~/.zshrc</code>下编辑你的配置就行了，各位别忘了把terminal的启动命令换成zsh</li></ul><p>接下来是我的一些个性化配置</p><ul><li>我用的是pure主题，oh-my-zsh已经把它加入默认的主题包里，你把默认的<code>ZSH_THEME=&quot;robbyrussell&quot;</code>改成<code>ZSH_THEME=&quot;pure&quot;</code>即可</li><li>但这不是最新的配置，可以去<a href="https://github.com/sindresorhus/pure" target="_blank" rel="external">pure</a>下载最新的主题，注意不要和原先的冲突（好吧，HyperTerm也是它告诉我的）</li></ul><ul><li><p>要高亮命令，需要<code>brew install zsh-syntax-highlighting</code>，然后在插件里加上<code>zsh-syntax-highlighting</code>就好了；</p></li><li><p>要配置<code>wake-time</code>，需要sudo pip install wakatime.</p></li><li><p>cd ~/.oh-my-zsh/custom/plugins &amp;&amp; git clone <a href="https://github.com/wbinglee/zsh-wakatime.git" target="_blank" rel="external">https://github.com/wbinglee/zsh-wakatime.git</a></p></li><li><p>然后在插件里加入zsh-wakatime就好了，过段时间就可以看统计信息了</p></li></ul><p><img src="http://7xkwu7.com1.z0.glb.clouddn.com/wakatime_for_terminal.png" alt=""></p><ul><li>你还可以加入autojump、osx这些小插件扩展，虽然感觉我装了也没怎么用…</li></ul><p>现在你的terminal就可以有我上图给的那样的效果了。</p><h2 id="Tmux-使用小记"><a href="#Tmux-使用小记" class="headerlink" title="Tmux 使用小记"></a>Tmux 使用小记</h2><p>tmux是个终端复用的工具，我看重它主要好用的地方有：</p><ul><li>分屏功能</li><li>现场恢复（未重启）</li></ul><p>安装直接<code>brew install tmux</code>即可，简单粗暴。</p><p>关于tmux的使用教程网上有很多，有些讲的挺透彻的，这里主要还是记录一些我个人常用的。</p><p>使用：</p><ul><li>tmux new -s session //用session为名创建一个新会话</li><li>tmux a -t your_session_name //恢复名为your_session_name的会话</li></ul><p>接下来讲讲它的配置，我换了一圈流行配置感觉还是下面这个比较搭我的terminal，其他的感觉都太臃肿太复杂了，github上star数最高那个安装就挺麻烦的…</p><p><img src="http://7xkwu7.com1.z0.glb.clouddn.com/tmux_config.png" alt=""></p><p>配置文件：<br>     去<a href="https://github.com/zanshin/dotfiles/tree/master/tmux下载配置文件" target="_blank" rel="external">https://github.com/zanshin/dotfiles/tree/master/tmux下载配置文件</a><br>     重命名为.tmux.conf放在你的~目录下<br>     用brew install reattach-to-user-namespace解决在mac下的一些问题<br>     用tmux source-file ~/.tmux.conf来启动你的配置</p><p>其中一些常用配置整理：</p><ul><li>prefix改成了`</li><li><code>prefix+|</code>左右分栏</li><li><code>prefix+-</code>上下分栏</li><li>默认开启鼠标选择pane模式</li></ul><p>还有挺多小功能的，像显示正在访问的ip啊什么的，目前我也是用一些学一些，下面贴上我学习的一些功能。</p><hr><h3 id="这里是功能更新区（据说是长期）"><a href="#这里是功能更新区（据说是长期）" class="headerlink" title="这里是功能更新区（据说是长期）"></a>这里是功能更新区（据说是长期）</h3><p>复制粘贴：</p><ul><li>prefix + [ 启动“copy-mode”、</li><li>像在vim下一样移动到你想去的那一行</li><li>使用v开始选择</li><li>像在vim一样选择你需要的内容，被选用的内容会被高亮</li><li>使用y复制所选内容</li><li>这样内容就在你粘贴板上了</li><li>你可以用pbpaste来查看刚刚复制的内容</li></ul><p>来自<a href="https://robots.thoughtbot.com/tmux-copy-paste-on-os-x-a-better-future" target="_blank" rel="external">https://robots.thoughtbot.com/tmux-copy-paste-on-os-x-a-better-future</a></p><hr><p>虽然时常还有些小bug，但tmux真的非常好用，可以说网络编程必备，平时经常和服务器打交道的小伙伴建议也学习一个。</p><p>怎么样，有没有觉得terminal也很好玩呐~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先上主要配置，想要自己折腾的同学自己可以行动起来了。&lt;/p&gt;
&lt;p&gt;配置推荐：&lt;strong&gt;HyperTerm&lt;/strong&gt;(&lt;code&gt;hyperterm-snazzy&lt;/code&gt;+ &lt;code&gt;hyperpower&lt;/code&gt; + &lt;code&gt;hyperpower-plus&lt;/code&gt; + &lt;code&gt;hyperline&lt;/code&gt;)+&lt;strong&gt;oh-my-zsh&lt;/strong&gt;(&lt;code&gt;pure&lt;/code&gt;+&lt;code&gt;git&lt;/code&gt;+&lt;code&gt;autojump&lt;/code&gt;+&lt;code&gt;osx&lt;/code&gt;+&lt;code&gt;zsh-syntax-highlighting&lt;/code&gt;+&lt;code&gt;zsh-wakatime&lt;/code&gt;)+&lt;strong&gt;Tmux&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里是显示效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xkwu7.com1.z0.glb.clouddn.com/HyperTerm.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Practice" scheme="https://mhxie.me/categories/Practice/"/>
    
    
      <category term="tool" scheme="https://mhxie.me/tags/tool/"/>
    
      <category term="mac" scheme="https://mhxie.me/tags/mac/"/>
    
      <category term="develop" scheme="https://mhxie.me/tags/develop/"/>
    
  </entry>
  
  <entry>
    <title>《C++并发编程》学习笔记（一）</title>
    <link href="https://mhxie.me/2016/03/19/Cpp%20PP1/"/>
    <id>https://mhxie.me/2016/03/19/Cpp PP1/</id>
    <published>2016-03-20T05:14:56.000Z</published>
    <updated>2018-10-08T05:00:26.292Z</updated>
    
    <content type="html"><![CDATA[<p>因为一些棘手的效率问题，手头的项目必须要引入并发编程。这里整理下我学习的《C++并发编程》的笔记，尽可能地记录下了重难点以及我练习的例程代码，作为自己学习的备忘，也供想要快速学习的人参考。不过还是建议直接去阅读原书，中英文版本的网盘链接我放在文章后面，请读者自取。</p><a id="more"></a><h3 id="第一章-你好，C-的并发世界"><a href="#第一章-你好，C-的并发世界" class="headerlink" title="第一章 你好，C++的并发世界"></a>第一章 你好，C++的并发世界</h3><h4 id="何为并发"><a href="#何为并发" class="headerlink" title="何为并发"></a>何为并发</h4><ul><li>任务切换(task switching)：<br>单核机 - 某一时刻下只能执行一个任务，通过任务切换达成并发效果，任务切换时需要切换上下文(context switch)；</li><li>硬件并发(hardware concurrency)：<br>多核机 - 真正的多任务同时执行，但是核心数仍然供不应求。</li></ul><p><img src="http://7xkwu7.com1.z0.glb.clouddn.com/%E5%B9%B6%E5%8F%91%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F.png" alt="并发的两种方式"></p><p>并发的两种方式</p><p><img src="http://7xkwu7.com1.z0.glb.clouddn.com/%E5%9B%9B%E4%BB%BB%E5%8A%A1%E4%B8%A4%E6%A0%B8%E5%BF%83.png" alt="四任务两核心"></p><p>四任务两核心</p><h4 id="并发的途径"><a href="#并发的途径" class="headerlink" title="并发的途径"></a>并发的途径</h4><ul><li>多进程并发<br> <img src="http://7xkwu7.com1.z0.glb.clouddn.com/%E5%B9%B6%E5%8F%91%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.png" alt=""></li><li>多线程并发<br> <img src="http://7xkwu7.com1.z0.glb.clouddn.com/%E8%BF%9B%E7%A8%8B%E5%86%85%E5%B9%B6%E5%8F%91%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1.png" alt=""></li></ul><h4 id="为什么使用并发"><a href="#为什么使用并发" class="headerlink" title="为什么使用并发"></a>为什么使用并发</h4><ul><li>为了分离关注点</li><li>为了性能提升</li></ul><h4 id="什么时候不能用并发"><a href="#什么时候不能用并发" class="headerlink" title="什么时候不能用并发"></a>什么时候不能用并发</h4><blockquote><p>知道何时不使用并发与知道何时使用它一样重要。基本上，不使用并发的唯一原因就是，收益比不上成本。使用并发的代码在很多情况下难以理解，因此编写和维护的多线程代码就会产生直接的脑力成本，同时额外的复杂性也可能引起更多的错误。除非潜在的性能增益足够大或关注点分离地足够清晰，能抵消所需的额外的开发时间以及与维护多线程代码相关的额外成本(代码正确的前提下)；否则，别用并发。</p></blockquote><h3 id="第二章-线程管理"><a href="#第二章-线程管理" class="headerlink" title="第二章 线程管理"></a>第二章 线程管理</h3><h4 id="线程管理基础"><a href="#线程管理基础" class="headerlink" title="线程管理基础"></a>线程管理基础</h4><ol><li><p>启动线程  </p><ul><li>线程在<code>std::thread</code>对象创建时启动。</li><li>为了让编译器识别<code>std::thread</code>类，需将<code>&lt;thread&gt;</code>头文件包含进去。</li><li><p><code>std::thread</code>可以用可调用(callable)类型构造</p><pre><code>class background_task{public:      void operator()() const      {       do_something();       do_something_else();      }};background_task f;std::thread my_thread(f);</code></pre></li><li><p>启动线程后需要明确是要等待线程结束(加入式)还是让其自主运行(分离式)，必须在对象销毁之前做出决定。</p><pre><code>清单2.1 函数已经结束，线程依旧访问局部变量struct func{      int&amp; i;      func(int&amp; i_) : i(i_) {}      void operator() ()      {           for (unsigned j=0 ; j&lt;1000000 ; ++j)            {          do_something(i);           // 1. 潜在访问隐患：悬空引用            }      }};void oops(){      int some_local_state=0;      func my_func(some_local_state);      std::thread my_thread(my_func);      my_thread.detach();          // 2. 不等待线程结束}                              // 3. 新线程可能还在运行</code></pre><p>  调用清单2.1中的<code>oops()</code>后，如果没有什么操作，看上去能够完美运行，可是一旦进行了某些操作，<code>i</code>引用地址的值就会发生改变，引发不想要的结果。</p></li></ul></li><li>等待线程完成<br> 如果需要等待线程，相关的<code>std::thread</code>实例需要使用<strong>join()</strong>，在清单2.1中将<code>my_thread.detach()</code>替换为<code>my_thread.join()</code>就可以确保局部变量在线程完成后才被销毁。<ul><li><strong>join()</strong>等待线程完成或不等待；</li><li><strong>join()</strong>清理了线程相关的存储部分，<code>std::thread</code>对象将不再与已经完成的线程有任何关联；</li><li>只能对一个线程使用一次<strong>join()</strong>，一旦用过，其<strong>joinable()</strong>将会返回false，表示不能再次加入。</li></ul></li><li><p>特殊情况下的等待<br> 如果打算等待对应线程，却因为线程运行后产生异常，在<strong>join()</strong>调用前被抛出，就意味着这次调用会被跳过。</p><ul><li>考虑用<code>try/catch</code>语句块在异常处理过程中调用<strong>join()</strong>，从而避免生命周期的问题</li><li><p>另一种方式是使用RALL(Resource Acquisition Is Initialization)，并提供一个类，在析构函数中调用<strong>join()</strong>。</p><pre><code>清单2.2 使用RAII等待线程完成class thread_guard{  std::thread&amp; t;public:  explicit thread_guard(std::thread&amp; t_):    t(t_)  {}  ~thread_guard()  {    if(t.joinable()) // ①    {      t.join();      // ②    }  }  thread_guard(thread_guard const&amp;)=delete;   // ③  thread_guard&amp; operator=(thread_guard const&amp;)=delete;};struct func; // 定义在清单2.1中void f(){  int some_local_state=0;  func my_func(some_local_state);  std::thread t(my_func);  thread_guard g(t);  do_something_in_current_thread();}    // ④</code></pre><p>  解析：当线程执行到④时，局部变量即将被逆序销毁，然而<code>thread_guard</code>的对象<strong>g</strong>是第一个被销毁的，这时会调用其析构函数，被加入到原始线程中。注意：析构函数中的<strong>joinable()</strong>判断很重要，因为<strong>join()</strong>只能对给定的对象调用一次；</p><blockquote><p>拷贝构造函数和拷贝赋值操作被标记为=delete③，是为了不让编译器自动生成它们。直接对一个对象进行拷贝或赋值是危险的，因为这可能会弄丢已经加入的线程。通过删除声明，任何尝试给thread_guard对象赋值的操作都会引发一个编译错误。</p></blockquote></li></ul></li><li><p>后台运行线程<br> 通常称分离线程为守护线程(<em>daemon threads</em>)，由<strong>detach()</strong>引发，c++运行库将会保证线程退出时现相关资源的正确回收，其归属和控制也由其处理。</p><ul><li>守护线程的特点是长时间运行，它没有任何用户接口，生命周期可能会从某一个应用起始到结束；</li><li>Fire and forget：分离线程只能确定什么时候会结束；</li><li>调用<strong>detach()</strong>后<strong>joinable()</strong>将会返回false；</li></ul></li></ol><p>这周就先学习到这里，欢迎大家留言交流。</p><p>中英文书籍：</p><ol><li><a href="http://pan.baidu.com/s/1qXxyxuk" target="_blank" rel="external"><em>英文版 - 网盘</em></a></li><li><a href="https://www.gitbook.com/book/chenxiaowei/cpp_concurrency_in_action/details" target="_blank" rel="external"><em>中文版 - GitBook</em></a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为一些棘手的效率问题，手头的项目必须要引入并发编程。这里整理下我学习的《C++并发编程》的笔记，尽可能地记录下了重难点以及我练习的例程代码，作为自己学习的备忘，也供想要快速学习的人参考。不过还是建议直接去阅读原书，中英文版本的网盘链接我放在文章后面，请读者自取。&lt;/p&gt;
    
    </summary>
    
      <category term="Practice" scheme="https://mhxie.me/categories/Practice/"/>
    
    
      <category term="c++" scheme="https://mhxie.me/tags/c/"/>
    
      <category term="Concurrency" scheme="https://mhxie.me/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>了解虚拟机</title>
    <link href="https://mhxie.me/2016/03/12/VM/"/>
    <id>https://mhxie.me/2016/03/12/VM/</id>
    <published>2016-03-13T07:53:50.000Z</published>
    <updated>2018-10-08T05:03:14.620Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟机是一款提供跨平台一致性体验的”软件”。<br>虚拟机最初被Popek and Goldberg定义为<em>“an efficient, isolated duplicate of a real machine”</em>。现在通常指与实际硬件不直接相关的虚拟机器。</p><a id="more"></a><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在传统意义上，一个应用程序是和特定平台（硬件+OS）所绑定的。用户层面上，这意味着你将无法在不同的平台上获得一致的体验，很多软件都只适配了某些特定的平台；开发者层面，因为不同系统适配的麻烦令许多中小开发者放弃对多平台的开发，这也是用户层面问题产生的重要原因。切换平台后，很多人会对新系统无所适从，发现常用的软件以及熟悉的操作方式不复存在。<br>虚拟机就是为了消除这种现实平台的限制而存在的，提供了一套更加灵活的解决方案。</p><h3 id="虚拟机的必要性"><a href="#虚拟机的必要性" class="headerlink" title="虚拟机的必要性"></a>虚拟机的必要性</h3><ol><li>便携性(Portability)在当今的网络计算下至关重要；</li><li>类型安全、面向对象编程、基于VM的语言成为主流；</li><li>CPU的创新往往被旧的接口所限制；</li><li>跨处理器的优化十分困难。</li></ol><h3 id="虚拟机的优点"><a href="#虚拟机的优点" class="headerlink" title="虚拟机的优点"></a>虚拟机的优点</h3><ol><li>跨平台的兼容性；</li><li>增加安全性；</li><li>提升性能；</li><li>简化软件迁移。</li></ol><h3 id="虚拟机的历史"><a href="#虚拟机的历史" class="headerlink" title="虚拟机的历史"></a>虚拟机的历史</h3><p>许多年前，IBM出售昂贵的主机给大型组织，并且产生了一个问题：要是组织想要同时在一台机器上运行不同的操作系统该怎么办？一些应用被开发在某个系统上然而有些却在其他系统上。结果IBM以Virtual machine monitor(VMM, also hypervisor)的方式间接实现了它。</p><h3 id="计算机系统的接口"><a href="#计算机系统的接口" class="headerlink" title="计算机系统的接口"></a>计算机系统的接口</h3><p>在介绍虚拟机之前，先介绍下计算机的结构，计算机系统是通过不同层级的抽象构建起来的，见下图：<br><img src="http://7xkwu7.com1.z0.glb.clouddn.com/Computer_Architecture.png" alt="Computer Architecture"></p><p>其中两类接口至关重要：</p><ol><li>ISA接口<br> Instruction Set Architecture，又称指令集或指令集体系。连接软硬件。包括用户级ISA（对应用和OS可见）和系统级ISA（仅对OS可见）</li><li>ABI接口<br> Application Binary Interface，是应用与OS间的接口，由用户级ISA和OS系统调用</li></ol><h3 id="虚拟机的分类系统"><a href="#虚拟机的分类系统" class="headerlink" title="虚拟机的分类系统"></a>虚拟机的分类系统</h3><ol><li><p>Process VMs<br>位于ABI层，将独立的进程虚拟化 - 虚拟机随进程终止而终止。<br>进程虚拟机将ABI层虚拟化，<strong>仿真</strong>了用户级ISA和OS系统调用，这里的VM也可以被称作runtime，VMM则被称作runtime system。<br>Runtime将负责管理客户程序，负责其与OS的沟通。客户程序可能会和主程序掺杂在一起。</p><ol><li>Same ISA<ul><li>Multiprogrammed Systems</li><li>Dynamic Binary Optimizers</li></ul></li><li><p>Different ISA</p><ul><li>Dynamic Translators</li><li>HLL VM - 高级语言虚拟机， 典型代表JVM，赋予了语言跨平台的特性</li></ul><p><img src="http://7xkwu7.com1.z0.glb.clouddn.com/ProcessVM%201.png" alt="ProcessVM_1"><br><img src="http://7xkwu7.com1.z0.glb.clouddn.com/ProcessVM%202.png" alt="ProcessVM_2"></p></li></ol></li><li>System VMs<br>位于ISA层，虚拟出一个完整的系统 - 支持多进程，支持设备I/O，支持GUI界面。<ol><li>Same ISA<ul><li>Classic System VM - VMM直接搭在纯硬件系统上(通常采用私密模式)，为客户系统解释和实现所有私密操作。</li><li>Hosted VM - 直接将VMM搭在常规宿主操作系统上，缺点是效率较低。</li></ul></li><li>Different ISA<ul><li>Whole System VM - 客户系统和宿主系统采用不同的ISA。</li><li>Codesigned VM - 为了能够使用一些创新的ISAs和/或硬件实现，从而能够提升性能与能耗<br><img src="http://7xkwu7.com1.z0.glb.clouddn.com/SystemVM_1.png" alt="SystemVM_1"><br><img src="http://7xkwu7.com1.z0.glb.clouddn.com/SystemVM_2.png" alt="SystemVM_2"></li></ul></li></ol></li></ol><h3 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h3><h4 id="纯硬件之上的虚拟化（本机执行）"><a href="#纯硬件之上的虚拟化（本机执行）" class="headerlink" title="纯硬件之上的虚拟化（本机执行）"></a>纯硬件之上的虚拟化（本机执行）</h4><p>这种方法被称之为对硬件完全的虚拟化，可以使用type 1或type 2的当时执行管理程序：type 1 管理程序直接跑在硬件上，type 2则跑在另一个操作系统之上。每个虚拟机上可以运行任何一个被底层硬件所支持的操作系统，用户也因此可以同时运行两个甚至更多的”Guest”操作系统，相互之间无法干涉。<br>这种虚拟机甚至可以是recursive的——虚拟机之上可以运行虚拟机。</p><h4 id="非本机系统模拟"><a href="#非本机系统模拟" class="headerlink" title="非本机系统模拟"></a>非本机系统模拟</h4><p>虚拟机可以承担模拟器的责任，让软件和操作系统为另一个计算机处理器的结构所运行。模拟可以完全是软件层面的，或者可能包含一些硬件的成份比如说微指令。</p><h4 id="操作系统级别的虚拟化"><a href="#操作系统级别的虚拟化" class="headerlink" title="操作系统级别的虚拟化"></a>操作系统级别的虚拟化</h4><p>这种虚拟化是在操作系统之上的服务器虚拟化技术。可以这么理解，一个单独的物理服务器被分片成好几个小部分（又称作VE, VPS, guests, zones, etc），每个部分从用户的角度看像是真的服务器一般。</p><p><strong>内容还很简陋，如有错误欢迎指出，不定期更新。</strong></p><p><em>Reference</em></p><ol><li>Virtual machine monitor, 2014, ARPACI-DUSSEAU， The easy piece</li><li><a href="https://www.wikiwand.com/en/Runtime_system" target="_blank" rel="external">Runtime system - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Virtual_machine" target="_blank" rel="external">Vitual machine - Wikiwand</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虚拟机是一款提供跨平台一致性体验的”软件”。&lt;br&gt;虚拟机最初被Popek and Goldberg定义为&lt;em&gt;“an efficient, isolated duplicate of a real machine”&lt;/em&gt;。现在通常指与实际硬件不直接相关的虚拟机器。&lt;/p&gt;
    
    </summary>
    
      <category term="Theory" scheme="https://mhxie.me/categories/Theory/"/>
    
    
      <category term="VM" scheme="https://mhxie.me/tags/VM/"/>
    
      <category term="OS" scheme="https://mhxie.me/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Prolog学习笔记（四）</title>
    <link href="https://mhxie.me/2015/10/18/Prolog4/"/>
    <id>https://mhxie.me/2015/10/18/Prolog4/</id>
    <published>2015-10-18T22:30:36.000Z</published>
    <updated>2018-10-08T05:01:31.401Z</updated>
    
    <content type="html"><![CDATA[<p>这周的主要内容是<strong>递归之于表</strong>以及<strong>内建谓词介绍</strong></p><a id="more"></a><h2 id="递归-amp-表"><a href="#递归-amp-表" class="headerlink" title="递归&amp;表"></a>递归&amp;表</h2><h3 id="引入——辨别一个表"><a href="#引入——辨别一个表" class="headerlink" title="引入——辨别一个表"></a>引入——辨别一个表</h3><p>我们说表是递归定义的，那么是否为表也可以用下面的一个递归规则来测试：</p><pre><code>is_a_list([]).is_a_list([_|T]) :-    is_a_list(T). %Head is replaced with an underscore as we don’t want to use it.</code></pre><h3 id="为什么使用递归"><a href="#为什么使用递归" class="headerlink" title="为什么使用递归"></a>为什么使用递归</h3><ul><li>它能让我们使用非常清晰和优雅的代码</li><li>关系也许是递归的</li><li>数据是递归定义的，最好的办法是迭代地处理</li><li>允许prolog在一个问题空间里进行一些复杂的搜索而不需要使用专用的算法</li></ul><h3 id="递归的形式"><a href="#递归的形式" class="headerlink" title="递归的形式"></a>递归的形式</h3><p>在Prolog里，递归的定义和其他语言是差不多的：</p><ol><li>首先，需要定义得到终止的条件</li><li>然后，就是定义怎样来使一个较大的问题分解成一个相似但是较小的wen<h3 id="递归的三种使用方法"><a href="#递归的三种使用方法" class="headerlink" title="递归的三种使用方法"></a>递归的三种使用方法</h3></li></ol><ol><li><p>先在<strong>base case</strong>中计算出结果，然后使用这个结果在程序中<strong>回溯</strong>；</p><pre><code>listlength([],0).listlength([_|T],N1):-      listlength(T,N),      N1 is N+1.</code></pre></li><li><p>在<strong>递归</strong>进入程序时收集结果，最终结束于<strong>base case</strong>；</p><pre><code>listlength([],Acc,Acc).% final resultlistlength([_|T],Acc,Out) :-    Acc1 is Acc+1,    % 当递归时累加器加一    listlength(T,Acc1,Out).</code></pre></li><li><p>使用<strong>未实例化</strong>的变量递归，然后在回溯时收集结果</p><pre><code>listlength() :-    listlenthlistless(List,0,Length).listlength2([], Acc, Acc). %利用了辅助谓词listlength2([_|T], Acc, Out) :-    Acc is Acc+1,    listlength(T,Accede,Out).</code></pre></li></ol><h2 id="内建谓词"><a href="#内建谓词" class="headerlink" title="内建谓词"></a>内建谓词</h2><p>按功能来分，内建谓词有以下三类</p><h3 id="一、识别术语"><a href="#一、识别术语" class="headerlink" title="一、识别术语"></a>一、识别术语</h3><p>以下的均为一元谓词，参数即需要判断的术语。</p><ul><li>var/1 判断变量</li><li>nonvar/1 判断非变量或已经实例化的变量</li><li>atom/1 判断原子</li><li>atomic/1 判断数或原子</li><li>number/1 判断数</li><li>integer/1 判断整数</li><li>float/1 判断浮点数</li><li>compound/1 判断结构</li><li>ground/1 判断是否包含未实例化的变量</li></ul><h3 id="二、分解结构"><a href="#二、分解结构" class="headerlink" title="二、分解结构"></a>二、分解结构</h3><ol><li><p>=../2</p><p> <strong>Term =.. L</strong><br> 当L是一个以Term中的主函数子为首，后面跟着它的变量为尾的<strong>表</strong>时为真。<br> ex:</p><pre><code>?- term(a,b,c) =.. L.L = [term, a, b, c].</code></pre></li><li><p>functor/3  </p><p> <strong>fuctor(Term,F,N)</strong><br> 当F是Term当的fuctor且N是F的参数数量时为真。<br> ex:</p><pre><code>?- functor(term(a,b,c),F,N).F = term,N = 3.</code></pre></li><li><p>arg/3</p><p> <strong>arg(N,Term,A)</strong><br> 当A是Term的第N个参数时为真<br> ex:</p><pre><code>?- arg(3,term(a,b,c),c).    true.</code></pre></li></ol><p>上面三个内建谓词通常用于组合使用。</p><h3 id="三、收集解答"><a href="#三、收集解答" class="headerlink" title="三、收集解答"></a>三、收集解答</h3><p>举个例子，当你想要找到一个目标的所有结果时，你通常会去这么使用谓词：<br>以member/2为例：</p><pre><code>?- member(X, [a,b,c,d]).</code></pre><p>回车，得到结果，然后不断敲击分号得到所有结果直至false（有的直接结束）。</p><pre><code>X = a ;X = b ;X = c ;X = d.</code></pre><p>然而，现在我们用一个谓词搞定这些。</p><ol><li><p>fingall/3<br> ex1:</p><pre><code>?- findall(X, member(X, [a,b,c,d]), Results).Results = [a, b, c, d].%输出的结果是列表形式的</code></pre><p> ex2:</p><pre><code>?- findall(X, (member(X, [1,2,3,4]),X &gt; 2), Results).Results = [3, 4].%第二个参数可以是一个目标，也可以是复合目标</code></pre><p> ex3:</p><pre><code>?- findall(X/Y, (member(X, [1,2,3,4]), Y is X*X), Results).Results = [1/1, 2/4, 3/9, 4/16].%第一个参数可以是一个复杂的集合，用合一的思想就很好理解</code></pre><p> 其他用法：</p><ul><li>变量的灵活使用</li><li>允许嵌套</li><li>^|等逻辑操作符在第二个参数中的使用</li></ul></li><li><p>setof/3</p><p> 和findall/3基本一致，差别就是它容许结果出现<strong>重复</strong>而且是<strong>升序排列</strong>的(不仅仅是数字)。</p></li><li><p>bagof/3</p><p> bagof/3和findall/3的区别就是bagof/3会输出第一个参数位置变量的结果，匹配第三个参数依次输出(意味着需要输入分号)，然而findall/3只关心第三个参数的结果，并将他们全部堆在一个表里输出。</p></li></ol><p>上面的三个谓词被统称为<strong>meta-predicates</strong>(元谓词)<br>    ——因为它们能够操纵Prolog的证明策略</p><hr><h3 id="Remark"><a href="#Remark" class="headerlink" title="Remark:"></a>Remark:</h3><p>学习的过程中产生了在prolog中<strong><em>双引号</em></strong>使用的疑惑，在<a href="http://stackoverflow.com" target="_blank" rel="external">stack overflow</a>上找到一个不错的<a href="http://stackoverflow.com/questions/8264699/what-is-the-difference-between-and-in-prolog" target="_blank" rel="external">回答</a></p><p>时间原因就不翻译了，贴出来给大家学习：</p><blockquote><p>Single quoted items are always atoms.</p><p>The meaning of double quotes depends on the Prolog flag double_quotes:</p><p><strong>atom</strong> — with this value <code>&quot;a&quot; = a</code>. Nowadays, this is rarely used. But you will find Prolog books where <code>[&quot;abc.pl&quot;]</code> is written.</p><p><strong>codes</strong> — a list of character codes. This is frequently the default, but it leads to very unreadable answers like</p><pre><code>   ?- phrase((&quot;Ja tvoi &quot;,(&quot;sluga&quot;|&quot;rabotnik&quot;),&quot;!&quot;), Satz).Satz = [74,97,32,116,118,111,105,32,115,108,117,103,97,33] ;Satz = [74,97,32,116,118,111,105,32,114,97,98,111,116,110,105,107,33].</code></pre><p>Even worse, if you use characters beyond ASCII:</p><pre><code>   ?- phrase((&quot;Я твой &quot;,(&quot;слуга&quot;|&quot;работник&quot;),&quot;!&quot;), Satz).Satz = [1071,32,1090,1074,1086,1081,32,1089,1083,1091,1075,1072,33] ;Satz = [1071,32,1090,1074,1086,1081,32,1088,1072,1073,1086,1090,1085,1080,1082,33].</code></pre><p><strong>chars</strong> — a list of one-char atoms.</p><pre><code>   ?- set_prolog_flag(double_quotes,chars).true.   ?- phrase((&quot;Ja tvoi &quot;,(&quot;sluga&quot;|&quot;rabotnik&quot;),&quot;!&quot;), Satz).Satz = [&apos;J&apos;,a,&apos; &apos;,t,v,o,i,&apos; &apos;,s,l,u,g,a,!] ;Satz = [&apos;J&apos;,a,&apos; &apos;,t,v,o,i,&apos; &apos;,r,a,b,o,t,n,i,k,!].   ?- phrase((&quot;Я твой &quot;,(&quot;слуга&quot;|&quot;работник&quot;),&quot;!&quot;), Satz).Satz = [&apos;Я&apos;,&apos; &apos;,т,в,о,й,&apos; &apos;,с,л,у,г,а,!] ;Satz = [&apos;Я&apos;,&apos; &apos;,т,в,о,й,&apos; &apos;,р,а,б,о,т,н,и,к,!].</code></pre><p>This notation gives more readable answers. It can be even more compactly displayed since the double quote notation can be used for printing any list of one-char atoms. For SWI, there is <a href="http://www.complang.tuwien.ac.at/ulrich/Prolog-inedit/double_quotes.pl" target="_blank" rel="external">library(double_quotes)</a>.</p><pre><code>   ?- use_module(library(double_quotes)).true.   ?- phrase((&quot;Ja tvoi &quot;,(&quot;sluga&quot;|&quot;rabotnik&quot;),&quot;!&quot;), Satz).Satz = &quot;Ja tvoi sluga!&quot; ;Satz = &quot;Ja tvoi rabotnik!&quot;.   ?- phrase((&quot;Я твой &quot;,(&quot;слуга&quot;|&quot;работник&quot;),&quot;!&quot;), Satz).Satz = &quot;Я твой слуга!&quot; ;Satz = &quot;Я твой работник!&quot;.</code></pre></blockquote><p><em>Reference:</em></p><ol><li><em>Prolog Programming for Artificial Intelligence 4th edition - chapter 6</em></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周的主要内容是&lt;strong&gt;递归之于表&lt;/strong&gt;以及&lt;strong&gt;内建谓词介绍&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Practice" scheme="https://mhxie.me/categories/Practice/"/>
    
    
      <category term="Prolog" scheme="https://mhxie.me/tags/Prolog/"/>
    
      <category term="AI" scheme="https://mhxie.me/tags/AI/"/>
    
      <category term="language" scheme="https://mhxie.me/tags/language/"/>
    
  </entry>
  
  <entry>
    <title>Prolog学习笔记（三）</title>
    <link href="https://mhxie.me/2015/10/05/Prolog3/"/>
    <id>https://mhxie.me/2015/10/05/Prolog3/</id>
    <published>2015-10-05T22:43:02.000Z</published>
    <updated>2018-10-08T05:01:28.296Z</updated>
    
    <content type="html"><![CDATA[<p>本周的重点是AND/OR树、结构体和表。<br>通过AND/OR树，我们可以很好地理解Prolog的证明策略；<br>结构体是（一）里没有介绍过的类型，要注意与<strong>事实(facts)</strong>的区别；<br>List的构造与使用让我们真正感受到了在prolog里递归的力量，你会感叹设计递归的精妙与艰辛:p</p><a id="more"></a><h3 id="Representing-Proofs-using-Trees"><a href="#Representing-Proofs-using-Trees" class="headerlink" title="Representing Proofs using Trees"></a>Representing Proofs using Trees</h3><p>为了更好地理解Prolog的证明策略，我们可以用AND/OR树来表示它的行为，利用下图来理解：</p><p><img src="http://7xkwu7.com1.z0.glb.clouddn.com/prologAND%3AOR%20Tree.png" alt=""></p><p>对应：<br>P :- Q, R.<br>P :- S.</p><p>Q :- T.<br>Q :- U.</p><p><strong>特征</strong></p><ol><li>询问是自顶向下(Top-Bottom)的</li><li>树向下生长</li><li>每一个分支表示一个子目标<ol><li>左边的数字表示序号</li><li>右边的表示变量以及其实例化</li></ol></li><li>每个分支结束于：<ol><li>成功的匹配用空心圆圈表示</li><li>不成功则在圆圈里加上叉或</li><li>另一个子目标（backtracking）</li></ol></li></ol><h3 id="Structures"><a href="#Structures" class="headerlink" title="Structures"></a>Structures</h3><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>结构体就是一个拥有一个或几个组成成分的对象，组成成分其本身也可以是结构体，这种嵌套的定义使得树的意义再一次在prolog里体现。</p><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>比方说1983年五月一日可以写成：</p><pre><code>date(1,May,1983)</code></pre><p>在这里date被称为functor（函数子？），这个结构的组成都是常数，实际上它可以是变量：</p><pre><code>date(Day,may,1983)</code></pre><p>它表示的是1983年五月的某一天（其实只是我们这么认为，当然可以有别的解释）</p><h5 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h5><p>结构体的匹配原则与在（二）里有较详尽介绍的合一一致。</p><h5 id="与事实的区别"><a href="#与事实的区别" class="headerlink" title="与事实的区别"></a>与事实的区别</h5><p>语法形式上结构和事实很像，但它们不是一个东西：</p><ol><li>当结构未被存储在数据库里时，它不是事实（需要以句号结尾）；</li><li>结构通常只被用在组织数据上；</li><li>它们的functors不需要去匹配谓词。</li></ol><p>但是谓词却能够以结构形式存储…</p><p>eg: <strong>command(X) :- X.</strong></p><pre><code>?- X = write(&apos;Passing a command&apos;), command(X).Passing a commandX = write(&apos;Passing a command&apos;) ?true</code></pre><p>是不是感觉有些混乱？关于facts、predicates、functors和terms，大家可以参考stackoverflow下的一个问答：<br><a href="http://stackoverflow.com/questions/19115712/in-prolog-is-a-fact-the-same-as-a-functor" target="_blank" rel="external">http://stackoverflow.com/questions/19115712/in-prolog-is-a-fact-the-same-as-a-functor</a></p><p>里面的问题是：</p><blockquote><p>If you have for instance next line of Prolog declaration:</p><pre><code>move(state(middle, onbox, middle, hasnot),      grasp,      state(middle, onbox, middle, has)).</code></pre><p>Are both move and state functors?</p><p>I’m kind off confused by facts, functors, terms, …</p></blockquote><p>这里截取一位热心网友的回答（太长就不翻译了）：</p><blockquote><p>In Prolog functors are syntactic elements we use to build structures (compound terms) from simpler ones.</p><p>Think of a hierarchy of bound Prolog terms, with the base containing the simplest “atomic” cases, i.e. atoms and numbers. Add to these Prolog variables, which may be bound or not depending on context. The rules for Prolog functor names (identifiers) are the same as for Prolog atoms</p><p>Functors are syntactic units that have a finite number of arguments (“arity”), and if a functor is supplied with terms for those arguments, then we get a compound term. In your example there is a principal functor move with three arguments, so its arity is 3. The functor name and arity are often combined, since technically Prolog treats the same functor name with two distinct arities as different functors, and so we might refer to move/3 as the outer functor of your compound term.</p><p>Note that the first and third arguments in your example of a term are themselves compound terms, built using functor state/4…</p></blockquote><p>更多的自己去原文链接看吧，个人觉得说的还是挺有道理的。</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>表(list)是一系列数据(包括表自己)的集合，由方括号包着，内部通过逗号(commmas)分隔。</p><p>eg：[ann, tennis, tom, skiing]<br>还可以是空的：[]</p><h5 id="不同的表示形式"><a href="#不同的表示形式" class="headerlink" title="不同的表示形式"></a>不同的表示形式</h5><p>第一个元素，我们称之为表头(<em>head</em>)，剩下的部分统称为尾(<em>tail</em>),所以在prolog里表又有不同的表示形式（喂喂，这里的因果关系有问题吧”(ºДº*)）。<br>.(Head, Tail)</p><p>所以上面的表可以表示为(可以用树来理解)：<br>.(ann,.(tennis,.(tom,.(sking,[]))))</p><p><img src="http://7xkwu7.com1.z0.glb.clouddn.com/prologlist_tree.png" alt=""></p><p>更为直观地表示为：<br>[Head | Tail]</p><p>这其实是list的递归表示，在polog里，它的存在让许多表的操作可以优雅地以<strong><em>递归</em></strong>方式实现，应用的例子直接从下面的List操作中体现。</p><h5 id="List-操作"><a href="#List-操作" class="headerlink" title="List 操作"></a>List 操作</h5><ol><li><p>concatenation（连接操作）<br> 实现：</p><pre><code>conc([], L2, L2).conc([H|T1],L2,[H|T]) :-    conc(T1, L2, T).</code></pre><p> 使用</p><pre><code>?- conc([a,b], [c,d], P).    P = [a, b, c, d].</code></pre><p> 实际上你还可以把它当删除用，在query时在List1或者List2的位置用变量就可以了。<br> 某种意义上可以用它实现接下来所有操作，但是有些操作还是重写比较简洁，也不容易出现问题，conc在连接单个元素时要注意加上[]，因为它并没有定义单个元素的base case，直接用常量会出现问题，prolog将不会认为那是一个list然后得出false的结论。</p></li><li><p>删除<br> 实现：</p><pre><code>delete(A,[A|X],X).delete(A,[B|X],[B|Y]) :-    delete(A,X,Y).</code></pre><p> 使用：</p><pre><code>?- delete(a, [a,b,e,a], L).L = [b, e, a] ;L = [a, b, e] ;false.</code></pre><p> 注意这种删除只支持删除一个元素，如果重复的话，它输出的是删除一次的不同情况。</p></li><li><p>头部添加<br> 实现：</p><pre><code>add_front(X, L , [X|L]).</code></pre><p> 使用：</p><pre><code>?- add(a,[b,c,d],L).L = [a, b, c, d].</code></pre></li><li><p>是否成员<br> 实现：</p><pre><code>mem(T,[T|_]).mem(A,[_|T]) :-    mem(A, T).</code></pre><p> 不写使用了，累了。</p><p> 这里的下划线(underscore)代表它只是个无用的变量，内容是什么无关紧要，prolog在查阅时会跳过它。</p></li><li><p>子表(sublist)<br> 实现：</p><pre><code>sublist(S, L) :-    conc(_, L2, L),    conc(S, _, L2).</code></pre><p> 使用：</p><pre><code>?- sublist(S, [a,b,c]).S = [] ;S = [a] ;S = [a, b] ;S = [a, b, c] ;S = [] ;S = [b] ;S = [b, c] ;S = [] ;S = [c] ;S = [] ;false.</code></pre><p> 这个使用conc比较好理解，你将会得到输入表的所有子表（注意左边的是子表，用反就没完没了了）。</p></li><li><p>插入<br> 实现：</p><pre><code>insert(X, L, D) :-    delete(X, D, L).</code></pre></li><li><p>计数<br> 实现：</p><pre><code>len([], 0).len([_|L], N) :-    len(L, N_),    N is N_ + 1.</code></pre></li><li><p>prolog里自带的list操作</p><p> 上面的的操作其实很多prolog已经写好了，直接调来用就可以了，这里给出我用的swi-prolog里的原生操作：</p><p> <img src="http://7xkwu7.com1.z0.glb.clouddn.com/prologlist.png" alt=""><br> 有点多，请读者自行在prolog下用help(谓词名)来获取实用信息。</p></li></ol><h5 id="list应用——全排列"><a href="#list应用——全排列" class="headerlink" title="list应用——全排列"></a>list应用——全排列</h5><ul><li><p>方法一</p><pre><code>permutation([], []).permutation([X|L], P) :-    permutation(L, L1),    insert(X, L1, P).</code></pre></li><li><p>方法二</p><pre><code>permutation([], []).permutation_(L, [X|P]) :-    delete(X, L, L1),    permutation(L1,P)</code></pre></li></ul><p><em>Reference:</em></p><ol><li><em>Prolog Programming for Artificial Intelligence 4th edition - chapter 2/3</em></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周的重点是AND/OR树、结构体和表。&lt;br&gt;通过AND/OR树，我们可以很好地理解Prolog的证明策略；&lt;br&gt;结构体是（一）里没有介绍过的类型，要注意与&lt;strong&gt;事实(facts)&lt;/strong&gt;的区别；&lt;br&gt;List的构造与使用让我们真正感受到了在prolog里递归的力量，你会感叹设计递归的精妙与艰辛:p&lt;/p&gt;
    
    </summary>
    
      <category term="Practice" scheme="https://mhxie.me/categories/Practice/"/>
    
    
      <category term="Prolog" scheme="https://mhxie.me/tags/Prolog/"/>
    
      <category term="AI" scheme="https://mhxie.me/tags/AI/"/>
    
      <category term="language" scheme="https://mhxie.me/tags/language/"/>
    
  </entry>
  
  <entry>
    <title>Prolog学习笔记（二）</title>
    <link href="https://mhxie.me/2015/09/27/Prolog2/"/>
    <id>https://mhxie.me/2015/09/27/Prolog2/</id>
    <published>2015-09-28T00:29:00.000Z</published>
    <updated>2018-10-08T05:01:24.616Z</updated>
    
    <content type="html"><![CDATA[<p>第三周：这周的主要内容是算数操作符，合一的概念还有跟踪和调试的方法。</p><p>这是第一个版本，时间仓促，没有怎么看书就发了出来，如有出错还请见谅，之后会对错误和遗漏进行修改。</p><a id="more"></a><h3 id="算数操作符-Arithmetic-Operators"><a href="#算数操作符-Arithmetic-Operators" class="headerlink" title="算数操作符(Arithmetic Operators)"></a>算数操作符(Arithmetic Operators)</h3><ol><li>操作符种类：<ul><li>运算操作符：+, -, *, /,^,mod（还可以使用div代表/，但是有所不同，/是实数除法，div是整数除法）</li><li>比较操作符：&lt;, &gt;, =&lt;, &gt;=, =:= (equals), =\= (not equals)</li></ul></li><li>操作符使用：表达式的返回值（可以这么解释吗）就是结果。<ul><li>前缀(prefix)：像用谓词一样使用即可；+(2,3)表达的就是2+3，还可以嵌套，这可以直观的用操作符树来表示；</li><li>中缀(infix)：和普通的计算公式相同相同；</li><li>后缀(postfix)：用的比较少；</li><li>自定义：可以通过自定义谓词来进行一些不同的计算过程，这周比较忙，这里就不再展开，先挖个坑<pre><code>&lt;我是坑&gt;</code></pre></li></ul></li><li>操作符优先级：^before mod before /, *, before +,-(和平时使用相同，括号的优先级最高)</li><li>计算结果：使用is才能够得到计算结果，不然只是一个表达式。<br> 对比：<pre><code>?- X = 2 + 3.X = 2+3.?- X is 2 + 3.X = 5.</code></pre></li></ol><h3 id="合一-Unification"><a href="#合一-Unification" class="headerlink" title="合一(Unification)"></a>合一(Unification)</h3><p>同一(Unify)概念是在 Prolog 背后的主要想法，它是逻辑学当中的一个的重要概念。《Prolog Programming for Artificial Intelligence》一书强调了出于效能的原因，在Prolog里用unification是不准确的，应该使用匹配(matching)，<br>    比如我们问Prolog：</p><pre><code> ?- X = f(X). 这句匹配请求应该是成功还是失败？在逻辑中的合一(Unification)，它应该是失败的，然而在prolog里就能实现。大家可以通过下面的跟踪感受一下： [trace]  ?- X = f(X), Y = X.   Call: (8) _G951=f(_G951) ? creep   Exit: (8) f(f(f(f(f(f(f(f(f(...)))))))))=f(f(f(f(f(f(f(f(f(...))))))))) ? creep   Call: (8) _G956=f(f(f(f(f(f(f(f(f(...))))))))) ? creep   Exit: (8) f(f(f(f(f(f(f(f(f(...)))))))))=f(f(f(f(f(f(f(f(f(...))))))))) ? creepX = Y, Y = f(Y).[trace]  ?- X = f(X), Y =f(X).   Call: (8) _G951=f(_G951) ? creep   Exit: (8) f(f(f(f(f(f(f(f(f(...)))))))))=f(f(f(f(f(f(f(f(f(...))))))))) ? creep   Call: (8) _G958=f(f(f(f(f(f(f(f(f(...))))))))) ? creep   Exit: (8) f(f(f(f(f(f(f(f(f(...)))))))))=f(f(f(f(f(f(f(f(f(...))))))))) ? creepX = Y, Y = f(_S1), % where_S1 = f(_S1).</code></pre><p>总而言之，它表示绑定变量的内容的机制并可以看作为一种只一次的(one-time)赋值。在 Prolog 中，这种操作用符号 “=” 来指示。</p><ol><li>在传统 Prolog 中，未实例化的变量 X —— 就是说在它上面以前没有进行合一，可以合一于一个原子、一个项、或另一个未实例化的变量，因此在效果上变成了它的别名。在很多现代 Prolog 方言和一阶逻辑演算中，变量<em>不能合一于包含它的项</em>；这叫做出现检查。</li><li>Prolog 原子只能合一于同一个原子。</li><li>类似的，项只能合一于另一个项，如果顶部函数符号和项的元数(arity)和这个项是一样的，并且参数可以同时合一。注意这是递归行为。<br>由于它的声明本性，一序列合一的次序(通常)是不重要的。</li></ol><p>注意： 在一阶逻辑的术语中，原子是基本命题而且其合一同 Prolog 项一样。<br>example:</p><pre><code>1. 这些是合一的：     red = fred.         true     ‘Hey you’ = ‘Hey you’.    true     fred=X.            X=fred.     X=Y.            Y=X.     foo(X) = foo(bar).        X=bar.     foo(N,N) = foo(bar, X).        N=X, X=bar.     foo(foo(bar)) = foo(X)        X=foo(bar)2. 这些不是合一的：     1 = sin(pi/2).     //1 is sin(pi/2).也是false，然而1 =:= sin(pi/2)是true     fred = jim.     ‘Hey you’ = ‘Hey me’.     frou(frou) = f(frou).     foo(bar) = foo(bar,bar).     foo(N,N) = foo(bar,rab).</code></pre><h3 id="其他命令："><a href="#其他命令：" class="headerlink" title="其他命令："></a>其他命令：</h3><ul><li>跟踪(Trace)：<pre><code>?- trace.//开始[trace] ?- notrace.//结束</code></pre></li><li>调试(Debug)：<pre><code>[trace] ?- notrace.//从跟踪结束[debug] ?- nodebug.//结束调试</code></pre></li></ul><p><em>Reference:</em></p><ol><li><em><a href="https://zh.wikipedia.org/wiki/合一" target="_blank" rel="external">https://zh.wikipedia.org/wiki/合一</a></em></li><li>_<a href="http://www.swi-prolog.org/pldoc/doc_for?object=manual" target="_blank" rel="external">http://www.swi-prolog.org/pldoc/doc_for?object=manual</a>_</li><li><em>Prolog Programming for Artificial Intelligence 4th edition - chapter 2、3</em></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第三周：这周的主要内容是算数操作符，合一的概念还有跟踪和调试的方法。&lt;/p&gt;
&lt;p&gt;这是第一个版本，时间仓促，没有怎么看书就发了出来，如有出错还请见谅，之后会对错误和遗漏进行修改。&lt;/p&gt;
    
    </summary>
    
      <category term="Practice" scheme="https://mhxie.me/categories/Practice/"/>
    
    
      <category term="Prolog" scheme="https://mhxie.me/tags/Prolog/"/>
    
      <category term="AI" scheme="https://mhxie.me/tags/AI/"/>
    
      <category term="language" scheme="https://mhxie.me/tags/language/"/>
    
  </entry>
  
  <entry>
    <title>Homebrew安装使用总结</title>
    <link href="https://mhxie.me/2015/09/19/Homebrew%20Usage/"/>
    <id>https://mhxie.me/2015/09/19/Homebrew Usage/</id>
    <published>2015-09-20T05:29:16.000Z</published>
    <updated>2018-10-08T05:00:47.612Z</updated>
    
    <content type="html"><![CDATA[<p>homebrew是一个小型的，非商业性质的套件管理器。<br>它能够自动化安装库或者软件，并且自动安装其所需要的依赖（不同于MacPorts，尽量使用系统自带的库），定制简单，上手容易，更新及时，而且是直接装在 /usr/local 下，减少很多各种 PATH 环境变量的定义（简直是开发必备啊）。</p><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>终端输入</p><pre><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)”//请去reference中的官网去更新最新脚本</code></pre><p>若安装失败，请检查安装条件：</p><ol><li>Intel的芯片</li><li>系统是OS X 10.6及以上</li><li>Xcode开发工具（xcode-select –install）</li><li>已安装Bourne shell</li></ol><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>终端输入</p><pre><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;</code></pre><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><pre><code>brew help//查看帮助信息brew search//加要寻找的关键字brew install//加要安装的包名称,安装最新的包及其依赖brew uninstall//加要卸载的包名称，卸载它brew update//升级自身brew list//列出所有已安装的包名称brew outdated//列出所有过时的包名称brew upgrade//升级所有，加包名升级对应包（注意旧版本会保留）brew cleanup//清除所有旧版本，-n用以查看信息，加包名清除对应包旧版本brew doctor//诊断Homebrew存在的问题并给出建议brew info//加包名查询对应信息，不加查询已安装的包的存储信息brew deps//加包名查询对应依赖brew pin//固定某一包的版本brew upin//解除固定</code></pre><h3 id="二阶命令——brew-cask使用"><a href="#二阶命令——brew-cask使用" class="headerlink" title="二阶命令——brew cask使用"></a>二阶命令——brew cask使用</h3><p>安装cask</p><pre><code>brew install cask</code></pre><p>之后就可以用brew cask 尽情地享受了~</p><pre><code>brew cask help//查看帮助信息</code></pre><p>懒得一个个写了，这里粘贴出来，很多都和brew命令相同，不同的是用cask是用来安装.app的</p><pre><code>alfred     displays note about new built-in alfred supportaudit      verifies installability of Caskscat        dump raw source of the given Cask to the standard outputcleanup    cleans up cached downloads and tracker symlinkscreate     creates the given Cask and opens it in an editordoctor     checks for configuration issuesedit       edits the given Caskfetch      downloads Cask resources to local cachehome       opens the homepage of the given Caskinfo       displays information about the given Caskinstall    installs the given Casklist       with no args, lists installed Casks; given installed Casks, lists staged filessearch     searches all known Casksuninstall  uninstalls the given Caskupdate     a synonym for &apos;brew update&apos;zap        zaps all files associated with the given Cask</code></pre><h3 id="高阶用法"><a href="#高阶用法" class="headerlink" title="高阶用法"></a>高阶用法</h3><pre><code>brew create//创建自己的Homebrew程式brew edit//使用 $EDITOR 编辑!</code></pre><p>详细用法可以参考：<a href="http://linfan.info/blog/2012/02/25/homebrew-installation-and-usage/" target="_blank" rel="external">http://linfan.info/blog/2012/02/25/homebrew-installation-and-usage/</a></p><p><em>Reference:</em></p><ol><li>官网地址： <a href="http://brew.sh" target="_blank" rel="external">http://brew.sh</a></li><li>命令说明： <a href="https://github.com/Homebrew/homebrew/blob/master/share/doc/homebrew/Formula-Cookbook.md" target="_blank" rel="external">https://github.com/Homebrew/homebrew/blob/master/share/doc/homebrew/Formula-Cookbook.md</a></li><li>官方文档： <a href="https://github.com/Homebrew/homebrew/tree/master/share/doc" target="_blank" rel="external">https://github.com/Homebrew/homebrew/tree/master/share/doc</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;homebrew是一个小型的，非商业性质的套件管理器。&lt;br&gt;它能够自动化安装库或者软件，并且自动安装其所需要的依赖（不同于MacPorts，尽量使用系统自带的库），定制简单，上手容易，更新及时，而且是直接装在 /usr/local 下，减少很多各种 PATH 环境变量的定义（简直是开发必备啊）。&lt;/p&gt;
    
    </summary>
    
      <category term="Practice" scheme="https://mhxie.me/categories/Practice/"/>
    
    
      <category term="tool" scheme="https://mhxie.me/tags/tool/"/>
    
      <category term="mac" scheme="https://mhxie.me/tags/mac/"/>
    
      <category term="develop" scheme="https://mhxie.me/tags/develop/"/>
    
  </entry>
  
  <entry>
    <title>Prolog学习笔记（一）</title>
    <link href="https://mhxie.me/2015/09/18/Prolog1/"/>
    <id>https://mhxie.me/2015/09/18/Prolog1/</id>
    <published>2015-09-19T04:18:00.000Z</published>
    <updated>2018-10-08T05:01:20.073Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>选修了人工智能导论，要求的语言就是prolog，上了两节觉得这个语言还是挺有趣的，和以前的完全不是一个风格，这里整理一下自己初步的学习。</p><h3 id="Prolog简介："><a href="#Prolog简介：" class="headerlink" title="Prolog简介："></a>Prolog简介：</h3><p>有别于一般的函数式语言，prolog的程序是基于谓词逻辑的理论。最基本的写法是定立对象与对象之间的关系，之后可以用询问目标的方式来查询各种对象之间的关系。系统会自动进行匹配及回溯，找出所询问的答案。</p><a id="more"></a><p>配置环境（macbook air）：</p><ol><li><p>直接用homebrew安装swi-prolog（没有安装的参见另一篇博文：<a href="http://xmhtech.me/2015/09/19/Homebrew安装使用总结/" target="_blank" rel="external">Homebrew 安装使用总结</a>）</p><blockquote><p>What is swim-prolog?<br>它是一个prolog的解释器</p></blockquote><p> brew install homebrew/x11/swi-prolog</p></li><li><p>常用命令</p><pre><code>swipl //调出主界面halt. //退出，Control+Dconsult(&apos;’). //reconsult().//</code></pre></li></ol><p>基本语法</p><ol><li>谓词(predicate)：Prolog的基本组成元素，可以是一段程序、一个数据类型或是一种关系，由谓词名和参数组成，名称相同、参数不同的谓词是不同的谓词；</li><li>参数(argument)：<ul><li>变量(variables)<ul><li>总是以大写字母或者下划线开始</li><li>对于变量没有类型而言，它能选用任何值</li><li>变量有它自己的作用域，其他子句的同名变量不会继承上一子句的值</li><li>变量可以被看做是全称量词，读作“任给”<br>*常量(constants) :<ul><li>原子(atom)：<ul><li>以小写字母开头，由字母、数字和下划线组成</li><li>由特殊符号组成</li><li>由单引号围起来的句子</li></ul></li><li>数字(number)：绝对值小于某数的正数或负数</li></ul></li></ul></li><li>结构体(structure)：后面介绍</li></ul></li><li>规则(rules)<ul><li>结论(子句头)：由条件决定是否为真</li><li>条件(子句体)：一系列用逗号隔离的目标，逗号被认作为“与”</li></ul></li><li>事实(facts)：可以看做只有头的规则</li><li>问题(query)：可以看做只有体的规则</li><li>注释(comment)<ul><li>单行：%</li><li>多行：/<em>开始</em>/结束</li></ul></li></ol><p>其他：</p><pre><code>1. 询问时，分号的作用：使当前子句无效，继续搜索答案。</code></pre><p><strong>Prolog是如何回答问题的?</strong></p><p>Prolog寻找证据的顺序正好与我们的推理相反，即执果索因，使用目标、规则、代换和当前目标来推导出新的目标，直到新目标恰好是简单事实时，给出答案。</p><p><em>Reference:</em></p><ol><li><em>Prolog Programming for Artificial Intelligence 4th edition - chapter 1</em></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;选修了人工智能导论，要求的语言就是prolog，上了两节觉得这个语言还是挺有趣的，和以前的完全不是一个风格，这里整理一下自己初步的学习。&lt;/p&gt;
&lt;h3 id=&quot;Prolog简介：&quot;&gt;&lt;a href=&quot;#Prolog简介：&quot; class=&quot;headerlink&quot; title=&quot;Prolog简介：&quot;&gt;&lt;/a&gt;Prolog简介：&lt;/h3&gt;&lt;p&gt;有别于一般的函数式语言，prolog的程序是基于谓词逻辑的理论。最基本的写法是定立对象与对象之间的关系，之后可以用询问目标的方式来查询各种对象之间的关系。系统会自动进行匹配及回溯，找出所询问的答案。&lt;/p&gt;
    
    </summary>
    
      <category term="Practice" scheme="https://mhxie.me/categories/Practice/"/>
    
    
      <category term="Prolog" scheme="https://mhxie.me/tags/Prolog/"/>
    
      <category term="AI" scheme="https://mhxie.me/tags/AI/"/>
    
      <category term="language" scheme="https://mhxie.me/tags/language/"/>
    
  </entry>
  
  <entry>
    <title>TL-WR703N v1.7 刷OpenWrt（译）</title>
    <link href="https://mhxie.me/2015/09/06/%5BTranslation%5DTL-WR703N/"/>
    <id>https://mhxie.me/2015/09/06/[Translation]TL-WR703N/</id>
    <published>2015-09-06T18:00:54.000Z</published>
    <updated>2018-10-08T05:00:10.337Z</updated>
    
    <content type="html"><![CDATA[<p>买了一台TP-Link wr703n准备刷OpenWrt用作开发，怎料官方挖了个大坑等我去跳——最新的官方固件封死网页刷机的渠道（据说是加了签名），又不会焊TTL的。。。幸好国外的大神已经给出了解决方案，亲测可行，替大家把原文翻译一下（有改动）。</p><a id="more"></a><p>原文出处：<a href="http://www.shadowandy.net/2015/03/flashing-tp-link-tl-wr703n-v1-7-to-openwrt.htm" target="_blank" rel="external">http://www.shadowandy.net/2015/03/flashing-tp-link-tl-wr703n-v1-7-to-openwrt.htm</a></p><h2 id="翻译水平有限大家将就看看哈，刷坏概不负责。"><a href="#翻译水平有限大家将就看看哈，刷坏概不负责。" class="headerlink" title="翻译水平有限大家将就看看哈，刷坏概不负责。"></a>翻译水平有限大家将就看看哈，刷坏概不负责。</h2><h3 id="获得必要的材料"><a href="#获得必要的材料" class="headerlink" title="获得必要的材料"></a>获得必要的材料</h3><p>将v1.7的TL-WR703N刷到OpenWrt，你需要：</p><ol><li>固件版本为3.17.1 Build 140120 Rel.56593n的TL-WR703N v1.7</li><li>OpenWrt为TL-WR703N定制的固件 <a href="http://downloads.openwrt.org/barrier_breaker/14.07/ar71xx/generic/openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-factory.bin" target="_blank" rel="external">Download</a></li><li>cURL以发送 crafted http 请求 <a href="http://curl.haxx.se/download.html" target="_blank" rel="external">Download</a></li><li>dd 以拆分 OpenWrt 为 kernel 和 rootfs 镜像 <a href="http://www.chrysocome.net/dd" target="_blank" rel="external">Download</a></li><li>TFTP 服务器（建议32位）<a href="http://tftpd32.jounin.net/" target="_blank" rel="external">Download</a></li><li>一个命令行脚本来指导路由器执行刷机.你需要一个编辑器 (e.g. Notepad++) 来创建一个Unix风格的脚本</li><li>busybox 1.16.1 for mips <a href="http://www.busybox.net/downloads/binaries/1.16.1/" target="_blank" rel="external">Download</a></li></ol><h3 id="准备开发wr703n的材料"><a href="#准备开发wr703n的材料" class="headerlink" title="准备开发wr703n的材料"></a>准备开发wr703n的材料</h3><ol><li><p>拆分 OpenWrt 为 kernel 和 rootfs 镜像</p><pre><code>dd if=openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-factory.bin of=i1 bs=1 count=1048576dd if=openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-factory.bin of=i2 bs=1 skip=1048576</code></pre></li><li><p>在你的电脑上设置局域网接口</p></li></ol><p>命令行脚本(aa)是在和IP地址192.168.1.9沟通。你可以修改电脑的静态IP也可以修改命令行脚本里的地址，这取决于你！</p><h3 id="开始刷机"><a href="#开始刷机" class="headerlink" title="开始刷机"></a>开始刷机</h3><ol><li><p>用必要的文件设置TFTP<br>现在你有以下四个文件：</p><ul><li>aa</li><li>i1</li><li>i2</li><li>busybox<br><strong>解压并执行</strong>TFTP服务器并且将操作根目录指向含有这四个文件的地方</li></ul></li><li><p>连接设备并且还原出厂设置（点击恢复出厂设置就好，不要干多余的事）</p></li><li><p>执行开发并升级<br> 在此之前，确认你电脑的静态IP为192.168.1.9</p><ol><li>将你的在命令行下的操作目录指向含有cURL的地方</li><li><p>依次执行以下三条命令</p><pre><code>curl -o - -b &quot;tLargeScreenP=1; subType=pcSub; Authorization=Basic%20YWRtaW46YWRtaW40Mg%3D%3D; ChgPwdSubTag=true&quot; &quot;http://192.168.1.1/&quot;curl -o - -b &quot;tLargeScreenP=1; subType=pcSub; Authorization=Basic%20YWRtaW46YWRtaW40Mg%3D%3D; ChgPwdSubTag=&quot; --referer &quot;http://192.168.1.1/userRpm/ParentCtrlRpm.htm&quot; &quot;http://192.168.1.1/userRpm/ParentCtrlRpm.htm?ctrl_enable=1&amp;parent_mac_addr=00-00-00-00-00-02&amp;Page=1&quot;curl -o - -b &quot;tLargeScreenP=1; subType=pcSub; Authorization=Basic%20YWRtaW46YWRtaW40Mg%3D%3D; ChgPwdSubTag=&quot; --referer &quot;http://192.168.1.1/userRpm/ParentCtrlRpm.htm?Modify=0&amp;Page=1&quot; &quot;http://192.168.1.1/userRpm/ParentCtrlRpm.htm?child_mac=00-00-00-00-00-01&amp;lan_lists=888&amp;url_comment=test&amp;url_0=;cd%20/tmp;&amp;url_1=;tftp%20-gl%20aa%20192.168.1.9;&amp;url_2=;sh%20aa;&amp;url_3=&amp;url_4=&amp;url_5=&amp;url_6=&amp;url_7=&amp;scheds_lists=255&amp;enable=1&amp;Changed=1&amp;SelIndex=0&amp;Page=1&amp;rule_mode=0&amp;Save=%B1%A3+%B4%E6&quot;</code></pre><p>判断命令是否执行成功：</p></li></ol><ul><li>如果命令一成功，登陆密码被修改为”admin42”</li><li>如果命令二成功，I can see the new parental item is added and enabled.(没看懂orz)</li><li><p>但是如果命令三成功，看起来没有任何事情发生（命令三有些慢，请不要慌）</p><p>备注：在过程中千万不要断开路由器的电源，否则你的路由器很有可能变砖！！！</p></li></ul></li><li>当路由器不再闪烁时，在浏览器输入192.168.1.1登陆Openwrt。</li><li>享受你的 TL-WR703N v1.7 吧</li></ol><p>这里是我刷机用过的工具和做好的材料，解压后使用——<a href="http://pan.baidu.com/share/link?shareid=3048068689&amp;uk=3694274917" target="_blank" rel="external">度盘</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;买了一台TP-Link wr703n准备刷OpenWrt用作开发，怎料官方挖了个大坑等我去跳——最新的官方固件封死网页刷机的渠道（据说是加了签名），又不会焊TTL的。。。幸好国外的大神已经给出了解决方案，亲测可行，替大家把原文翻译一下（有改动）。&lt;/p&gt;
    
    </summary>
    
      <category term="Practice" scheme="https://mhxie.me/categories/Practice/"/>
    
    
      <category term="OpenWrt" scheme="https://mhxie.me/tags/OpenWrt/"/>
    
      <category term="router" scheme="https://mhxie.me/tags/router/"/>
    
      <category term="Translation" scheme="https://mhxie.me/tags/Translation/"/>
    
  </entry>
  
  <entry>
    <title>初识SDN</title>
    <link href="https://mhxie.me/2015/09/05/First%20Glance%20at%20SDN/"/>
    <id>https://mhxie.me/2015/09/05/First Glance at SDN/</id>
    <published>2015-09-05T17:51:23.000Z</published>
    <updated>2018-10-08T05:00:43.102Z</updated>
    
    <content type="html"><![CDATA[<p><strong>SDN</strong>是一种为了解决传统网络中各种问题，比如管理困难、维护困难、拓展性差、灵活性差等，而出现的<strong>新型</strong>的<em><strong>网络架构</strong></em>。它的核心特征是实现了控制平面和数据平面的分离、控制逻辑集中和网络可编程。它的意义在于淡化底层设备的作用，让网络硬件的设计更加简单通用，打破“<strong>厂商锁定</strong>”，并且在这之上建立一个开放的网络操作系统，让开发者进入网络服务开发的门槛更低，建立起一个大三层网络生态系统，激发网络<em><strong>创新</strong></em>，给用户带来更好的使用体验。</p><a id="more"></a><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="http://7xkwu7.com1.z0.glb.clouddn.com/sdnsdn-3layers-2.gif" alt=""><br><em>图片出自ONF</em></p><p><a href="https://www.opennetworking.org" target="_blank" rel="external">ONF</a>提出的典型架构分为三层（从上到下依次是）：</p><ul><li>应用层（应用平面）</li><li>控制层（控制平面）</li><li>基础设施层（数据平面）</li></ul><p><em>备注：连接底下两层的被称为南向接口，连接顶上两层则被称为北向接口，控制层内部的连接被称为东西向接口。</em></p><h3 id="核心特征"><a href="#核心特征" class="headerlink" title="核心特征"></a>核心特征</h3><ul><li><p>控制逻辑集中：传统网络中分散的控制在SDN网络中被集中了起来，并且获得了空前的对全网的信息掌控，在此基础上很多复杂的操作都将被简化。</p></li><li><p>网络可编程 (programmability)：SDN网络中的北向接口，屏蔽了下层网络的细节，兼容多种高级语言，降低了开发者进入网络开发领域的门槛。</p></li><li><p>数据控制分离：传统网络体系里数据平面和控制平面都是分布式的，相互之间通过协议协作，但是这种分布式的网络控制不可避免地将会带来管理和维护的麻烦，而且出现问题可能也是连动式地，对于故障的定位也是一个大问题。SDN网络在这种分布式网络中分离出了控制部分，让所有上层的控制决策都由一个远端的控制器或者控制集群来下发。</p></li></ul><h3 id="各层简介"><a href="#各层简介" class="headerlink" title="各层简介"></a>各层简介</h3><h4 id="（一）数据平面"><a href="#（一）数据平面" class="headerlink" title="（一）数据平面"></a>（一）数据平面</h4><p>传统交换设备的功能架构包含了控制平面和数据平面，在物理上是紧耦合的，各种转发设备均与协议相关。SDN数据平面的交换设备专注于高速转发数据分组，转发决策由南向接口下发，实现了硬件设计的精简化，提升了效率。</p><p>SDN交换机设计：</p><ol><li>转发决策(Forwarding Decision)<br>数据分组进入交换机后，先与流表进行匹配查找，匹配成功则执行相应处理动作，失败则上交控制器由之决策，流程依赖于内部的SDN交换芯片，也是设备速率的瓶颈所在。</li><li>背板转发(Backplane)<br>交换机通过背板将各个端口连接，经由背板从输入端口转发到目的端口，为保证顺序，这里有个队列，队列满数据可能会被丢弃。</li><li>输出链路调度(Output Link Scheduling)<br>当数据分组到达SDN交换机的设备出端口后，在队列里等待，直到它被发出到相应的交换机输出链路上。</li></ol><h4 id="（二）控制平面"><a href="#（二）控制平面" class="headerlink" title="（二）控制平面"></a>（二）控制平面</h4><p>控制平面向上提供应用接口，向下指挥硬件转发，是整个SDN架构中最核心的部分。<br>类似于计算机的操作系统，设计SDN控制器的体系可以以之为参考。<br>控制器（Controller）是控制平面的核心组件，它是一个运行在服务器上的软件程序，可以用不同的语言运行在不同的操作系统上。<br>SDN控制器的设计多种多样，但一般要考虑到以下几个方面：</p><ol><li>北向接口：不同的控制器北向接口差异可以很大；</li><li>南向接口：不同于OpenFlow控制器，SDN控制器可以是更加灵活的，而已支持其他南向接口甚至私有接口，这也是设备制造商差异化服务的体现；</li><li>东西向接口（控制方式）：单点控制存在可拓展性、可靠性、安全性等一系列问题，所以必须要设计分布式的控制器集群，通常这个集群会有一个Master；</li><li>网络功能：除了北向接口，控制器还可以提供不同的网络功能，一些服务和应用可以内置在系统里（像手机的预装软件，这也是厂商在疯狂争夺控制器市场的重要原因之一）；</li><li>可扩展性：从内部看要考虑到增删网络功能模块对系统的稳定性，从外部看要考虑到对不同使用场景的适应能力；</li><li>安全性：系统级别的安全防御是很有必要的，在这一层要能够拦截下绝大部分网络攻击；</li><li>可靠性：要考虑到集群某一个或几个控制器故障或者遭受攻击的情况，要立刻启动应急机制，像是备份控制器。</li></ol><h4 id="（三）应用平面"><a href="#（三）应用平面" class="headerlink" title="（三）应用平面"></a>（三）应用平面</h4><p>SDN应用平面正是SDN体现其创新平台作用的地方，与传统网络相比，SDN网络将拥有更强的智能型，动态控制性和可编程性。<br>在当前主流SDN网络应用平面上，主要有以下三种类型的应用：</p><ol><li>资源管理平台<br>  在资源管理平台上整合SDN交付的网络控制能力是为了满足云计算资源调配自动化的需求，那些由标准步骤构成的流程最适合用专门的脚本来模拟反复，资源管理平台以软件的形式实现了对网络资源包括计算、存储和网络的协同交付。所以，SDN也是助力云计算发展的一大利器；</li><li>软件定义的应用交付<br>  网络上一直存在着改善网络服务的性能和体验的应用，例如Web安全、访问控制、负载均衡、应用加速、WAN优化、入侵检测等。它们在网络安全、管理方面发挥了重要作用，然而随着SDN的发展，这些原本集成在各层硬件上的服务也可以以软件形式被部署在服务器上，还可以是和控制器共用一个服务器，由于控制器具备全网视角，集中化的网络管理能力也从另一个侧面强化了这些网络应用的作用方式和范围。但是也要注意这会增加控制器的工作量以及网络受攻击的风险，同样的道理，这种影响也是全网级别的。</li><li>创新网络业务<br>  这类应用形式并不统一，但它一定是一些传统网络难以胜任而在SDN环境下能获得良好支持的一些软件。这也正是SDN网络未来的发展所在。</li></ol><h3 id="接口技术"><a href="#接口技术" class="headerlink" title="接口技术"></a>接口技术</h3><ul><li><p>南向接口：SDN控制器通过南向接口对SDN交换机进行集中管理，目前OpenFlow协议是由ONF唯一确定的控制器标准南向接口（还有与之配套的OF-CONFIG配置协议，用于远程配置OpenFlow交换机），也有一些其他的接口。</p></li><li><p>北向接口：网络应用开发者可以利用北向接口，以软件编程的形式实现对网络资源的调用，灵活性强。</p></li><li><p>东西向接口：控制平面如果采用单点设计难以应对各种网络问题，而且存在安全性、可靠性、扩展性等诸多问题，所以采用控制器集群式设计是较为合理的做法，控制器集群的沟通协作就需要一个新的规范——这就是东西向接口。</p></li></ul><p><em>Reference</em></p><ol><li>《软件定义网络——核心原理与应用实践》，人民邮电出版社，黄韬，刘江，魏亮，张娇，刘韵洁；  </li><li>《SDN核心技术剖析和实战指南》，电子工业出版社，雷葆华，王峰，王茜，王和宇等；  </li><li>《深度解析SDN——利益、战略、技术、实践》，电子工业出版社，张卫峰。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;SDN&lt;/strong&gt;是一种为了解决传统网络中各种问题，比如管理困难、维护困难、拓展性差、灵活性差等，而出现的&lt;strong&gt;新型&lt;/strong&gt;的&lt;em&gt;&lt;strong&gt;网络架构&lt;/strong&gt;&lt;/em&gt;。它的核心特征是实现了控制平面和数据平面的分离、控制逻辑集中和网络可编程。它的意义在于淡化底层设备的作用，让网络硬件的设计更加简单通用，打破“&lt;strong&gt;厂商锁定&lt;/strong&gt;”，并且在这之上建立一个开放的网络操作系统，让开发者进入网络服务开发的门槛更低，建立起一个大三层网络生态系统，激发网络&lt;em&gt;&lt;strong&gt;创新&lt;/strong&gt;&lt;/em&gt;，给用户带来更好的使用体验。&lt;/p&gt;
    
    </summary>
    
      <category term="Theory" scheme="https://mhxie.me/categories/Theory/"/>
    
    
      <category term="SDN" scheme="https://mhxie.me/tags/SDN/"/>
    
      <category term="Network" scheme="https://mhxie.me/tags/Network/"/>
    
      <category term="summary" scheme="https://mhxie.me/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>从搜索引擎谈起</title>
    <link href="https://mhxie.me/2015/08/07/Search%20Engine/"/>
    <id>https://mhxie.me/2015/08/07/Search Engine/</id>
    <published>2015-08-08T03:31:08.000Z</published>
    <updated>2018-10-08T05:02:43.955Z</updated>
    
    <content type="html"><![CDATA[<p>心血来潮想整理下一些关于搜索的奇技淫巧。在这个信息爆炸的时代不会用搜索不仅仅是一件令人遗憾的事情，可能会对你的生活都造成影响。能够快速、准确地利用搜索引擎找到自己想要的信息和资源，也是一件令人骄傲的事。</p><p>不过搜出来的很多技巧倒是让我大吃一惊，在这里分享出来。</p><a id="more"></a><h2 id="你所不知道的谷歌的用法"><a href="#你所不知道的谷歌的用法" class="headerlink" title="你所不知道的谷歌的用法"></a>你所不知道的谷歌的用法</h2><p>哦，首先你得学会科学上网，等哪天我再写一篇科学上网方法的汇总。<br>如果实在不会，可以尝试<a href="http://www.gfsoso.com" target="_blank" rel="external">谷粉搜搜</a>  </p><p>把以下的字符组合加在关键词(句)前：</p><ul><li><code>&quot; &quot;</code>以整个短语为关键字(完全匹配搜索)，而不是拆开</li><li><code>-</code>排除某个关键字的搜索结果</li><li><code>~</code>同时搜索它后面的近义词</li><li><code>..</code>显示指定年份你时间段内的搜索结果<br>  例如 ：2013..2015会搜索2013年到2015年的所有结果</li><li><code>site:</code>只搜索某个网站的页面</li><li><code>filetype:</code>只搜索指定后缀的文件</li><li><code>intitle:</code>只显示标题中含有该关键字的结果</li><li><code>allintitle:</code>搜索返回的是页面标题中包含多组关键词的文件</li><li><code>inurl:</code>用于搜索查询词出现在url中的页面</li><li><code>allinurl:</code>搜索返回的是出现在url中包含多组关键词的文件</li><li><code>inanchor:</code>指令返回的结果是导入链接锚文字中包含搜索词的页面</li><li><code>related:</code>返回的结果是与某个网站有关的页面(这个有关该怎么定义就不大清楚了，一般认为指的是有共同外部链接的网站)</li><li><code>*</code>用于代替任何字符，或者应该说是单词</li><li><code>author:</code>搜索作者名字里含关键字的文章——谷歌学术</li><li><code>&quot; &quot;</code>可以在引号里输入作者的全名或者缩写——谷歌学术</li><li><code>OR</code>用在两个关键词中间搜索任意一个出现的网页</li><li><code>link:</code>搜索含有某个链接的网页</li><li><code>cache:</code>用了搜索谷歌服务器上的缓存，用于查找死链</li><li><code>info:</code>提供cache、link、related和完全包含该信息的网页</li></ul><p>以上基本的语法，组合起来会有更多更多奇妙的效果</p><h2 id="除了谷歌，我们还有什么"><a href="#除了谷歌，我们还有什么" class="headerlink" title="除了谷歌，我们还有什么"></a>除了谷歌，我们还有什么</h2><p>首先祭出大杀器：<br><a href="http://so.chongbuluo.com" target="_blank" rel="external">快搜-搜索快人一步</a><br>这个亦可以看看吧<br><a href="http://s.f2do.com" target="_blank" rel="external">多维搜索 - 同时搜索多个维度的数据</a></p><p>以下搜索引擎其实只要了解一些就可以通过谷歌搜索出来，相当于二阶搜索的技巧</p><p><a href="www.baidu.com">百度</a><br><a href="www.google.com">谷歌</a><br><a href="www.bing.com">必应</a><br><a href="https://www.sogou.com" target="_blank" rel="external">搜狗</a><br><a href="http://www.haosou.com" target="_blank" rel="external">好搜</a>——360的搜索产品</p><p><a href="https://www.taobao.com" target="_blank" rel="external">淘宝</a><br><a href="http://weixin.sogou.com" target="_blank" rel="external">微信搜索</a>——搜狗微信搜索<br><a href="http://s.weibo.com" target="_blank" rel="external">微博搜索</a></p><p><a href="https://scholar.google.com" target="_blank" rel="external">谷歌学术</a><br><a href="http://xueshu.baidu.com" target="_blank" rel="external">百度学术</a><br><a href="">超星发现</a>  </p><p><a href="http://so.baiduyun.me" target="_blank" rel="external">百度网盘</a>  </p><p><a href="http://www.soopat.com" target="_blank" rel="external">soopat</a>——搜索专利的一个网站<br><a href="https://www.quora.com" target="_blank" rel="external">quora</a><br><a href="http://www.wolframalpha.com" target="_blank" rel="external">wolframalpha</a></p><h2 id="搜索的自我提升"><a href="#搜索的自我提升" class="headerlink" title="搜索的自我提升"></a>搜索的自我提升</h2><p>随着搜索次数的增加，搜索的效率是会不断提升的，要学会<strong>复盘</strong>，保存之前搜索的结果，试试有没有更快更准确的别的方法。很多时候之前搜到的信息也能够作为你下一次搜索的参考来实现关键字优化（应该说是某种矫正吗）<br>如果没有搜到，去思考为什么会搜不到，是不是应该搜索，是不是应该在这里搜索…</p><h2 id="Small-Tips"><a href="#Small-Tips" class="headerlink" title="Small Tips"></a>Small Tips</h2><ol><li><p>更换语言搜索  </p><blockquote><p>曾经做过女性产品，需要性感美女照片，国内美女要考虑肖像权。所以我就把＂性感美女    ＂这个关键词换成其他国家语言，拿到Google上搜，法国，英国，韩国，日本，我想要的    还真的都有，很好用。<br> 当然，用日文搜，往往还有意外收获。</p></blockquote><p> 但我想这个只适用于图片音乐什么的吧，不然你搜到了也看不懂。（突然觉得那种会好几种语言的好牛逼，获取信息的竞赛他们在一开始就领先于我们，但转念一想自己其实连中文和英文的信息都不可能吃透，会更多的语言也许也是烦恼:p）<br> 不过最好的应该还是用英文关键字检索，世界上大多数信息还是集中在英文网页中的。</p></li><li><p>积累关键字——每个专业领域内都有一些专业术语，而这些术语出现在媒体或口语中都是俗称，要想查到高质量的结果，就要有把术语和俗称进行转换的能力。另外，经过长期检验，有一些专家和记者非常靠谱，在搜索问题时同时加入他们的名字，得到的结果质量会高很多。</p></li><li>找出<strong>背后</strong>的脸——灵活使用此技巧,你可以过滤Google的图片搜索,使之只出现人的图像.这有什么用?这么说吧,如果你要找一个有名的人的图片,但是与之同名的产品,公司或者地理位置什么的会使你困扰,这个小技巧能让你更得心应手.想使用这个方法,你只需要在标准图片搜索之后在URL地址后面加上后缀&amp;imgtype=face  </li><li>浏览全球范围内的公开摄像头——你可以通过搜索Google随机地浏览全球范围内的摄像头流媒体.这可能不是最有效的Google技巧,但却是最有趣的!(作者:你可能需要立即安装一个ActiveX控件或者Java运行环境,以允许你的浏览器获取这些视频流格式)</li><li>在谷歌/必应里搜索百度网盘(<strong>网站积累</strong>)——加site:pan.baidu.com，将这个技巧泛化可以得到很多应用，但是首先你得知道site:后面要填什么，所以平时要注意网站的积累，这个博客也会不定期更新，我会把我所知道最新最有用的网站贴给大家。(也可以是<code>关键字 + &quot;(网址)&quot;</code>的形式)<br> (1) site:evernote.com/pub/——利用这种方法可以搜索到无私贡献出自己高质量笔记本的大牛们的私活，绝赞好评！！！（site:evernote.com/shard/——单个笔记）<br> (2)</li></ol><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>回到最初的问题，滥用搜索引擎真的好吗？且不说搜索引擎带给我们的答案是否正确，作为工具，它确实给我们带来了许多的便利，但同时我们也要注意使用这个工具所带来的潜在风险。</p><ul><li>钝化思维：很多时候，我们自己不能解决的问题，问一下搜索引擎就好了，午饭吃什么，生病了要吃什么，什么衣服比较流行诸如此类生活化问题搜索引擎也会帮你找到相关网页让你得到你可能想要的答案，可是这些问题真的值得上搜索引擎问嘛？或者问搜索引擎真的对吗？</li><li>信息质量良莠不齐：搜索引擎不会告诉你哪些回答是对的哪些回答是错的，而且也不排除你会把对的答案用在了错的地方，对于网络上浩如烟海的信息资源，如何辨别衡量他们的质量便是一个很大的问题，不过像是某度的知道就给出了对回答的评价机制，让网友来辨别答案的真假，这在一定程度上给了我们更多的信息去辨别。</li><li>效率问题：有的时候你费尽去搜索，得不到答案也是一件很苦恼的事情，虽然总好过得到了一个错误的答案，但你总归把时间浪费在了这上面，如果说你能得到一些促进你得到结果的idea也算还好，什么都没得到只顾搜索那就违背了我们使用搜索引擎的初衷。</li></ul><p>所以在使用搜索引擎前要好好衡量以上的几点因素，不要到最后成为一个离开搜素引擎就没用了的废物。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>突然觉得以前一搜就搜出几千万的结果然后没翻几页就决定结果的行为甚是草率，如何精确、准确定位自己所需要的资源或信息，我还有很长一段路要走。  </p><h4 id="后记：有针对地去寻找资源和信息——不定期更新"><a href="#后记：有针对地去寻找资源和信息——不定期更新" class="headerlink" title="后记：有针对地去寻找资源和信息——不定期更新"></a>后记：有针对地去寻找资源和信息——不定期更新</h4><p>很多时候搜索引擎显得并不是那么好用，有些高质量的论坛、网站里面相当于已经帮你做好了一次筛选，虽然搜出来可能不是几百几千万结果，但这些地方也许有更多的可能有你想要的答案，因为它已经帮你筛选过了，而且得到的结果的准确率往往也会高许多。</p><ol><li>书籍</li><li>图片<ul><li>素材</li><li>壁纸</li><li>以图搜图<ul><li><a href="http://tineye.com/" target="_blank" rel="external">Tineye</a></li><li><a href="http://www.gazopa.com/" target="_blank" rel="external">GazoPa</a></li><li><a href="http://similar-images.googlelabs.com/" target="_blank" rel="external">GoogleLab</a></li></ul></li></ul></li><li>音乐</li><li>视频</li><li>软件<ul><li>Mobile<ul><li>iOS</li><li>Android</li><li>Windows</li></ul></li><li>PC<ul><li>OS X</li><li>Windows</li><li>Linux<br>*</li></ul></li></ul></li><li>种子</li><li>人<ul><li><a href="http://www.bing.com/yxl?mkt=zh-CN" target="_blank" rel="external">必应影响力</a></li></ul></li><li>学术  <ul><li><a href="http://dir.cnki.net" target="_blank" rel="external">学术网站大全</a>——堪称学术的集大成导航</li><li><a href="http://www.nature.com" target="_blank" rel="external">Nature</a></li><li><a href="https://www.acm.org" target="_blank" rel="external">ACM</a>——The world’s largest educational and scientific computing society<br>*</li></ul></li><li>代码<ul><li><a href="https://github.com/search" target="_blank" rel="external">Code Search</a></li><li><a href="http://www.codase.com" target="_blank" rel="external">Codase</a></li><li><a href="http://sourceforge.net" target="_blank" rel="external">Sourceforge</a></li></ul></li><li>资讯</li><li>高质量论坛/社区/问答类网站<ul><li><a href="http://www.zhihu.com" target="_blank" rel="external">知乎</a></li><li><a href="http://www.quora.com" target="_blank" rel="external">Quora</a></li></ul></li><li>公开课<ul><li><a href="https://www.coursera.org" target="_blank" rel="external">coursera</a></li><li><a href="https://www.udacity.com" target="_blank" rel="external">udacity</a></li><li><a href="https://www.edx.org" target="_blank" rel="external">edX</a></li><li><a href="http://www.imooc.com" target="_blank" rel="external">慕课网</a></li><li><a href="http://www.duobei.com" target="_blank" rel="external">多贝公开课</a></li><li><a href="http://study.163.com" target="_blank" rel="external">网易云课堂</a></li></ul></li><li>资源下载<ul><li><a href="http://down.51cto.com" target="_blank" rel="external">51CTO</a>——IT资料</li></ul></li></ol><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><ol><li><a href="http://www.zhihu.com/question/20161362" target="_blank" rel="external">知乎：如何用好 Google 等搜索引擎？</a></li><li><a href="http://www.zhihu.com/question/23233662" target="_blank" rel="external">知乎：你有什么在网上搜索东西的神搜索技巧？</a></li><li><a href="http://www.zhihu.com/question/20251786" target="_blank" rel="external">知乎：有哪些特殊的搜索引擎</a></li></ol><p>下一篇<code>搜索进阶</code>我将会结合自己的想法和前辈的经验，总结一下搜索的步骤。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;心血来潮想整理下一些关于搜索的奇技淫巧。在这个信息爆炸的时代不会用搜索不仅仅是一件令人遗憾的事情，可能会对你的生活都造成影响。能够快速、准确地利用搜索引擎找到自己想要的信息和资源，也是一件令人骄傲的事。&lt;/p&gt;
&lt;p&gt;不过搜出来的很多技巧倒是让我大吃一惊，在这里分享出来。&lt;/p&gt;
    
    </summary>
    
      <category term="Theory" scheme="https://mhxie.me/categories/Theory/"/>
    
    
      <category term="Resource" scheme="https://mhxie.me/tags/Resource/"/>
    
      <category term="Google" scheme="https://mhxie.me/tags/Google/"/>
    
      <category term="info" scheme="https://mhxie.me/tags/info/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 学习</title>
    <link href="https://mhxie.me/2015/08/05/Learn%20MD/"/>
    <id>https://mhxie.me/2015/08/05/Learn MD/</id>
    <published>2015-08-06T03:22:48.000Z</published>
    <updated>2018-10-08T05:01:09.107Z</updated>
    
    <content type="html"><![CDATA[<p>刚建好自己的小窝，第一篇正式的博文记录了自己学习的Markdown语法，毕竟以后都要使用它来写博客，大家多多指教。<br><a id="more"></a></p><h3 id="斜体设置"><a href="#斜体设置" class="headerlink" title="斜体设置"></a>斜体设置</h3><p>你需要在需要斜体的部分前后加上一个underscore（下划线），像<em>这样</em>。</p><h3 id="粗体设置"><a href="#粗体设置" class="headerlink" title="粗体设置"></a>粗体设置</h3><p>你需要在需要粗体的部分都加上两个asterisks（星号）,像<strong>这样</strong>。<br>这里有个小插曲，我发现加一个asterisks是<em>这样</em>，也是斜体。</p><p><strong>以上两种语法的组合不分先后.</strong></p><h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><p>你需要使用反引号 (`)(在键盘上位于1的左边)把文字括起来来表示<code>行内代码</code></p><h3 id="标题设置"><a href="#标题设置" class="headerlink" title="标题设置"></a>标题设置</h3><p>你需要在你的标题前面加若干个连续的hash mark（俗称井号），井号越多字体越小，最多六个，像这样：</p><h1 id="重要的事情说三遍"><a href="#重要的事情说三遍" class="headerlink" title="重要的事情说三遍"></a>重要的事情说三遍</h1><h2 id="重要的事情说三遍-1"><a href="#重要的事情说三遍-1" class="headerlink" title="重要的事情说三遍"></a>重要的事情说三遍</h2><h3 id="重要的事情说三遍-2"><a href="#重要的事情说三遍-2" class="headerlink" title="重要的事情说三遍"></a>重要的事情说三遍</h3><h4 id="因为很重要所以再说三遍"><a href="#因为很重要所以再说三遍" class="headerlink" title="因为很重要所以再说三遍"></a>因为很重要所以再说三遍</h4><h5 id="因为很重要所以再说三遍-1"><a href="#因为很重要所以再说三遍-1" class="headerlink" title="因为很重要所以再说三遍"></a>因为很重要所以再说三遍</h5><h6 id="因为很重要所以再说三遍-2"><a href="#因为很重要所以再说三遍-2" class="headerlink" title="因为很重要所以再说三遍"></a>因为很重要所以再说三遍</h6><pre><code>注意hash mark只有在行首才有用，否则会失去它本身的作用而被无情地显示出来T_T</code></pre><p>只要hash mark在行首，对后面的内容部分你可以随意地用上面介绍的两个语法让文字<em>变斜</em>，或者<strong>加粗</strong>。<br>    还有一个要提醒大家的地方就是——<strong>慎用</strong>一号标题和六号标题！！！</p><p>以上的标题设置我们称之为<strong>类atx</strong>形式的语法，接下来要介绍另一种局限性比较大的标题设置语法——<strong>类Setext</strong>形式语法。<br>类 Setext 形式是用底线的形式，利用 =（最高阶标题）和 -（第二阶标题），任意数量的 = 和 - 加在要作为标题的文本下方即可。</p><h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。</p><h3 id="网页链接"><a href="#网页链接" class="headerlink" title="网页链接"></a>网页链接</h3><p>在Markdown的语法里有两种链接网页的方式：</p><h5 id="第一种：Inline-Link"><a href="#第一种：Inline-Link" class="headerlink" title="第一种：Inline Link"></a>第一种：Inline Link</h5><p>在你想显示的文本外边框起brackets（方括号），紧接着在后边用parenthesis（圆括号）框起这段文字指向的链接，例如：<br>    <a href="http://mhxie.me">千万不要点这里</a><br>Remark:  </p><ul><li>brackets和parenthesis都是半角的;</li><li>还有前两种语法对brackets里的内容也适用;</li><li>标题里也可以添加链接;</li></ul><h5 id="第二种：Reference-Link"><a href="#第二种：Reference-Link" class="headerlink" title="第二种：Reference Link"></a>第二种：Reference Link</h5><p>正如Reference的意思，这种链接网页的方式实际上是对文档内其他位置的链接的引用。它的语法是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：</p><pre><code>This is [an example][id] reference-style link.</code></pre><p>你也可以选择性地在两个方括号中间加上一个空格：</p><pre><code>This is [an example] [id]reference-style link.</code></pre><p>接着，在文件的任意处，你可以把这个标记的链接内容定义出来：</p><pre><code>[id]: http://example.com/  &quot;Optional Title Here&quot;</code></pre><p>链接内容定义的形式为：</p><ul><li>方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字</li><li>接着一个冒号</li><li>接着一个以上的空格或制表符</li><li>接着链接的网址</li><li>选择性地接着 title 内容，可以用单引号、双引号或是括弧包着</li></ul><p>下面这三种链接的定义都是相同：</p><pre><code>[foo]: http://example.com/  &quot;Optional Title Here&quot;[foo]: http://example.com/  &apos;Optional Title Here&apos;[foo]: http://example.com/  (Optional Title Here)</code></pre><p>这样做的一个好处是，当多个link指向同一个网址时，更新时只需要修改一个地方，方便也不容易忘记。</p><h5 id="第三种：Auto-Link"><a href="#第三种：Auto-Link" class="headerlink" title="第三种：Auto Link"></a>第三种：Auto Link</h5><p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样。</p><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><p>当你已经学会插入网页链接时，插入图片也不是什么难事了，插入图片也有两种方式，要做的只是把先前网页链接的部分换成图片的外链地址，为了区别于网站链接而将图片显示出来，在方括号前面加上一个exclamation point（叹号）即可<br><img src="http://7xkwu7.com1.z0.glb.clouddn.com/doge_sleep_icon.png" alt="A representation of Octdrey Catburn"></p><p>但是非常可惜的是，这种方法并不能调整图片的长宽，想要调整，还是得学习一点相关的Html语法。</p><h3 id="Blockquote（引用区块）"><a href="#Blockquote（引用区块）" class="headerlink" title="Blockquote（引用区块）"></a>Blockquote（引用区块）</h3><p>引用区块就是利用一句话或者一个段落的特殊格式来引起读者注意的语法。要做到这件事情也是十分简单，只要在要引用的句子或段落的前面加上”greater than” caret（大于号）就可以了，例如：</p><blockquote><p>If you need to call special attention to a quote from another source, or design a pull quote for a magazine article, then Markdown’s blockquote syntax will be useful. A blockquote is a sentence or paragraph that’s been specially formatted to draw attention to the reader.</p><p>To create a block quote, all you have to do is preface a line with the “greater than” caret.</p></blockquote><p>Blockquote还支持嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt;</p><h3 id="Codeblock（代码区块）"><a href="#Codeblock（代码区块）" class="headerlink" title="Codeblock（代码区块）"></a>Codeblock（代码区块）</h3><p>在Markdown里添加代码也非常简单，只需要缩进一个table（制表符）或者四个space（空格）就好了。<br>注意代码区块里斜体加粗引用等Markdown语法都会失效。</p><pre><code>#inluce&lt;iostream&gt;using namespce std;int main(){    cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl;    return 0;}</code></pre><h3 id="创建列表"><a href="#创建列表" class="headerlink" title="创建列表"></a>创建列表</h3><h5 id="第一种：Unordered-List（无序列表）"><a href="#第一种：Unordered-List（无序列表）" class="headerlink" title="第一种：Unordered List（无序列表）"></a>第一种：Unordered List（无序列表）</h5><p>It’s easy.在每一项的前面加上asterisk（星号）就好，记得星号后面要留一个space（空格）或table（制表符）哦，<strong>还有一个特殊的地方就是在这里plus sign（加号）和minus sign（减号）可以与asterisk混用。</strong></p><h5 id="第二种：Ordered-List（有序列表）"><a href="#第二种：Ordered-List（有序列表）" class="headerlink" title="第二种：Ordered List（有序列表）"></a>第二种：Ordered List（有序列表）</h5><p>有序列表就是数字加上一个半角句点和一个space或table就好了。但是要注意不小心产生有序列表的情况，所以尽量避免数字半角句点和space/table连续出现的情况，实在无法避免在句点前加上一个backslash（反斜杠）即可——<strong><em>反斜杠通常被利用来来插入一些在语法中有其它意义的符号(又被称作转义符)</em></strong>.</p><p>Remark：在实践中，我发现一个有趣的现象，就是有序列表只要制定了开头，后边的序号可以不用写，用asterisk/minus sign/plus sign代替也是可以，这样的话它会自动递增地帮你打印出序号来。</p><h5 id="多级列表的处理"><a href="#多级列表的处理" class="headerlink" title="多级列表的处理"></a>多级列表的处理</h5><p>在新一级的标识符前加上table来缩进即可，打印出来的效果像这样</p><ul><li>First level<ul><li>Second level<ul><li>Third level<ul><li>Fourth level</li></ul></li></ul></li></ul></li></ul><h3 id="创建表格"><a href="#创建表格" class="headerlink" title="创建表格"></a>创建表格</h3><p>这个并不是<strong>Markdown</strong>的标准语法，似乎需要解释器，先看看能不能发上来。<br>示例：</p><pre><code>H1 |H2 |H3---|---|---0,0|0,1|0,21,0|1,1|1,22,0|2,1|2,2</code></pre><table><thead><tr><th>H1</th><th>H2</th><th>H3</th></tr></thead><tbody><tr><td>0,0</td><td>0,1</td><td>0,2</td></tr><tr><td>1,0</td><td>1,1</td><td>1,2</td></tr><tr><td>2,0</td><td>2,1</td><td>2,2</td></tr></tbody></table><h3 id="段落和换行"><a href="#段落和换行" class="headerlink" title="段落和换行"></a>段落和换行</h3><p>你在实际操作中会发现，即使你在编辑时输入return（回车），显示出来的仍旧是一行，在Marhdown语法里也有两种方式来实现换行：</p><h5 id="Hard-Break"><a href="#Hard-Break" class="headerlink" title="Hard Break"></a>Hard Break</h5><p>直接再输入一个return（回车），这样段落的间距比较大。</p><h5 id="Soft-Break"><a href="#Soft-Break" class="headerlink" title="Soft Break"></a>Soft Break</h5><p>在段末输两个连续的space（空格），这样段落的间距会比较小。</p><p>总的来说，Markdown语法还是十分简单易学的，还有就是建议大家还是在实践中学习会比较快。<br>最后，感谢这个Markdown教程的网站，它提供了训练式的Markdown学习，对我的帮助十分大。<a href="http://markdowntutorial.com/" target="_blank" rel="external">http://markdowntutorial.com/</a>也十分感谢<a href="http://www.appinn.com/markdown/#img" target="_blank" rel="external"><em>Markdown 语法说明 (简体中文版)</em></a>告诉我许多其他的语法作为补充</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚建好自己的小窝，第一篇正式的博文记录了自己学习的Markdown语法，毕竟以后都要使用它来写博客，大家多多指教。&lt;br&gt;
    
    </summary>
    
      <category term="Practice" scheme="https://mhxie.me/categories/Practice/"/>
    
    
      <category term="web" scheme="https://mhxie.me/tags/web/"/>
    
  </entry>
  
</feed>
