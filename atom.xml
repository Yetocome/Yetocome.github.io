<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Xie's blog]]></title>
  <subtitle><![CDATA[Any idea or discussion is highly welcomed.250745820@qq.com]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://xmhtech.me//"/>
  <updated>2015-10-06T08:56:30.000Z</updated>
  <id>http://xmhtech.me//</id>
  
  <author>
    <name><![CDATA[Xie Minghao]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Prolog学习笔记（三）]]></title>
    <link href="http://xmhtech.me/2015/10/05/Prolog%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://xmhtech.me/2015/10/05/Prolog学习笔记（三）/</id>
    <published>2015-10-05T07:43:02.000Z</published>
    <updated>2015-10-06T08:56:30.000Z</updated>
    <content type="html"><![CDATA[<p>本周的重点是AND/OR树、结构体和表。<br>通过AND/OR树，我们可以很好地理解Prolog的证明策略；<br>结构体是（一）里没有介绍过的类型，要注意与<strong>事实(facts)</strong>的区别；<br>List的构造与使用让我们真正感受到了在prolog里递归的力量，你会感叹设计递归的精妙与艰辛:p</p>
<a id="more"></a>
<h3 id="Representing_Proofs_using_Trees">Representing Proofs using Trees</h3><p>为了更好地理解Prolog的证明策略，我们可以用AND/OR树来表示它的行为，利用下图来理解：</p>
<p><img src="http://7xkwu7.com1.z0.glb.clouddn.com/prologAND%3AOR%20Tree.png" alt=""></p>
<p>对应：<br>P :- Q, R.<br>P :- S.</p>
<p>Q :- T.<br>Q :- U.</p>
<p><strong>特征</strong></p>
<ol>
<li>询问是自顶向下(Top-Bottom)的</li>
<li>树向下生长</li>
<li>每一个分支表示一个子目标<ol>
<li>左边的数字表示序号</li>
<li>右边的表示变量以及其实例化</li>
</ol>
</li>
<li>每个分支结束于：<ol>
<li>成功的匹配用空心圆圈表示</li>
<li>不成功则在圆圈里加上叉或</li>
<li>另一个子目标（backtracking）</li>
</ol>
</li>
</ol>
<h3 id="Structures">Structures</h3><h5 id="简介">简介</h5><p>结构体就是一个拥有一个或几个组成成分的对象，组成成分其本身也可以是结构体，这种嵌套的定义使得树的意义再一次在prolog里体现。</p>
<h5 id="使用">使用</h5><p>比方说1983年五月一日可以写成：</p>
<pre><code><span class="function"><span class="title">date</span><span class="params">(<span class="number">1</span>,May,<span class="number">1983</span>)</span></span>
</code></pre><p>在这里date被称为functor（函数子？），这个结构的组成都是常数，实际上它可以是变量：</p>
<pre><code><span class="function"><span class="title">date</span><span class="params">(Day,may,<span class="number">1983</span>)</span></span>
</code></pre><p>它表示的是1983年五月的某一天（其实只是我们这么认为，当然可以有别的解释）</p>
<h5 id="匹配">匹配</h5><p>结构体的匹配原则与在（二）里有较详尽介绍的合一一致。</p>
<h5 id="与事实的区别">与事实的区别</h5><p>语法形式上结构和事实很像，但它们不是一个东西：</p>
<ol>
<li>当结构未被存储在数据库里时，它不是事实（需要以句号结尾）；</li>
<li>结构通常只被用在组织数据上；</li>
<li>它们的functors不需要去匹配谓词。</li>
</ol>
<p>但是谓词却能够以结构形式存储…</p>
<p>eg: <strong>command(X) :- X.</strong></p>
<pre><code>?- X = <span class="built_in">write</span>(<span class="string">'Passing a command'</span>), <span class="command"><span class="keyword">command</span>(<span class="title">X</span>).</span>
Passing <span class="operator">a</span> <span class="command"><span class="keyword">command</span></span>
X = <span class="built_in">write</span>(<span class="string">'Passing a command'</span>) ?
<span class="constant">true</span>
</code></pre><p>是不是感觉有些混乱？关于facts、predicates、functors和terms，大家可以参考stackoverflow下的一个问答：<br><a href="http://stackoverflow.com/questions/19115712/in-prolog-is-a-fact-the-same-as-a-functor" target="_blank" rel="external">http://stackoverflow.com/questions/19115712/in-prolog-is-a-fact-the-same-as-a-functor</a></p>
<p>里面的问题是：</p>
<blockquote>
<p>If you have for instance next line of Prolog declaration:</p>
<pre><code>move(<span class="keyword">state</span>(middle, onbox, middle, hasnot),
      grasp,
      <span class="keyword">state</span>(middle, onbox, middle, has)).
</code></pre><p>Are both move and state functors?</p>
<p>I’m kind off confused by facts, functors, terms, …</p>
</blockquote>
<p>这里截取一位热心网友的回答（太长就不翻译了）：</p>
<blockquote>
<p>In Prolog functors are syntactic elements we use to build structures (compound terms) from simpler ones.</p>
<p>Think of a hierarchy of bound Prolog terms, with the base containing the simplest “atomic” cases, i.e. atoms and numbers. Add to these Prolog variables, which may be bound or not depending on context. The rules for Prolog functor names (identifiers) are the same as for Prolog atoms</p>
<p>Functors are syntactic units that have a finite number of arguments (“arity”), and if a functor is supplied with terms for those arguments, then we get a compound term. In your example there is a principal functor move with three arguments, so its arity is 3. The functor name and arity are often combined, since technically Prolog treats the same functor name with two distinct arities as different functors, and so we might refer to move/3 as the outer functor of your compound term.</p>
<p>Note that the first and third arguments in your example of a term are themselves compound terms, built using functor state/4…</p>
</blockquote>
<p>更多的自己去原文链接看吧，个人觉得说的还是挺有道理的。</p>
<h3 id="List">List</h3><p>表(list)是一系列数据(包括表自己)的集合，由方括号包着，内部通过逗号(commmas)分隔。</p>
<p>eg：[ann, tennis, tom, skiing]<br>还可以是空的：[]</p>
<h5 id="不同的表示形式">不同的表示形式</h5><p>第一个元素，我们称之为表头(<em>head</em>)，剩下的部分统称为尾(<em>tail</em>),所以在prolog里表又有不同的表示形式（喂喂，这里的因果关系有问题吧”(ºДº*)）。<br>.(Head, Tail)</p>
<p>所以上面的表可以表示为(可以用树来理解)：<br>.(ann,.(tennis,.(tom,.(sking,[]))))</p>
<p><img src="http://7xkwu7.com1.z0.glb.clouddn.com/prologlist_tree.png" alt=""></p>
<p>更为直观地表示为：<br>[Head | Tail]</p>
<p>这其实是list的递归表示，在polog里，它的存在让许多表的操作可以优雅地以<strong><em>递归</em></strong>方式实现，应用的例子直接从下面的List操作中体现。</p>
<h5 id="List_操作">List 操作</h5><ol>
<li><p>concatenation（连接操作）<br> 实现：</p>
<pre><code><span class="function"><span class="title">conc</span><span class="params">([], L2, L2)</span></span>.
<span class="function"><span class="title">conc</span><span class="params">([H|T1],L2,[H|T])</span></span> :-
    <span class="function"><span class="title">conc</span><span class="params">(T1, L2, T)</span></span>.
</code></pre><p> 使用</p>
<pre><code>?- <span class="atom">conc</span>([<span class="atom">a</span>,<span class="atom">b</span>], [<span class="atom">c</span>,<span class="atom">d</span>], <span class="name">P</span>).
    <span class="name">P</span> = [<span class="atom">a</span>, <span class="atom">b</span>, <span class="atom">c</span>, <span class="atom">d</span>].
</code></pre><p> 实际上你还可以把它当删除用，在query时在List1或者List2的位置用变量就可以了。<br> 某种意义上可以用它实现接下来所有操作，但是有些操作还是重写比较简洁，也不容易出现问题，conc在连接单个元素时要注意加上[]，因为它并没有定义单个元素的base case，直接用常量会出现问题，prolog将不会认为那是一个list然后得出false的结论。</p>
</li>
<li><p>删除<br> 实现：</p>
<pre><code><span class="function"><span class="title">delete</span><span class="params">(A,[A|X],X)</span></span>.
<span class="function"><span class="title">delete</span><span class="params">(A,[B|X],[B|Y])</span></span> :-
    <span class="function"><span class="title">delete</span><span class="params">(A,X,Y)</span></span>.
</code></pre><p> 使用：</p>
<pre><code>?- delete(<span class="literal">a</span>, [<span class="literal">a</span>,b,e,<span class="literal">a</span>], L).
L = [b, e, <span class="literal">a</span>] <span class="comment">;</span>
L = [<span class="literal">a</span>, b, e] <span class="comment">;</span>
<span class="literal">false</span>.
</code></pre><p> 注意这种删除只支持删除一个元素，如果重复的话，它输出的是删除一次的不同情况。</p>
</li>
<li><p>头部添加<br> 实现：</p>
<pre><code><span class="function"><span class="title">add_front</span><span class="params">(X, L , [X|L])</span></span>.
</code></pre><p> 使用：</p>
<pre><code>?- <span class="atom">add</span>(<span class="atom">a</span>,[<span class="atom">b</span>,<span class="atom">c</span>,<span class="atom">d</span>],<span class="name">L</span>).
<span class="name">L</span> = [<span class="atom">a</span>, <span class="atom">b</span>, <span class="atom">c</span>, <span class="atom">d</span>].
</code></pre></li>
<li><p>是否成员<br> 实现：</p>
<pre><code><span class="function"><span class="title">mem</span><span class="params">(T,[T|_])</span></span>.
<span class="function"><span class="title">mem</span><span class="params">(A,[_|T])</span></span> :-
    <span class="function"><span class="title">mem</span><span class="params">(A, T)</span></span>.
</code></pre><p> 不写使用了，累了。</p>
<p> 这里的下划线(underscore)代表它只是个无用的变量，内容是什么无关紧要，prolog在查阅时会跳过它。</p>
</li>
<li><p>子表(sublist)<br> 实现：</p>
<pre><code><span class="function"><span class="title">sublist</span><span class="params">(S, L)</span></span> :-
    <span class="function"><span class="title">conc</span><span class="params">(_, L2, L)</span></span>,
    <span class="function"><span class="title">conc</span><span class="params">(S, _, L2)</span></span>.
</code></pre><p> 使用：</p>
<pre><code>?- <span class="atom">sublist</span>(<span class="name">S</span>, [<span class="atom">a</span>,<span class="atom">b</span>,<span class="atom">c</span>]).
<span class="name">S</span> = [] ;
<span class="name">S</span> = [<span class="atom">a</span>] ;
<span class="name">S</span> = [<span class="atom">a</span>, <span class="atom">b</span>] ;
<span class="name">S</span> = [<span class="atom">a</span>, <span class="atom">b</span>, <span class="atom">c</span>] ;
<span class="name">S</span> = [] ;
<span class="name">S</span> = [<span class="atom">b</span>] ;
<span class="name">S</span> = [<span class="atom">b</span>, <span class="atom">c</span>] ;
<span class="name">S</span> = [] ;
<span class="name">S</span> = [<span class="atom">c</span>] ;
<span class="name">S</span> = [] ;
<span class="atom">false</span>.
</code></pre><p> 这个使用conc比较好理解，你将会得到输入表的所有子表（注意左边的是子表，用反就没完没了了）。</p>
</li>
<li><p>插入<br> 实现：</p>
<pre><code><span class="operator"><span class="keyword">insert</span>(X, <span class="keyword">L</span>, <span class="keyword">D</span>) :-
    <span class="keyword">delete</span>(X, <span class="keyword">D</span>, <span class="keyword">L</span>).</span>
</code></pre></li>
<li><p>计数<br> 实现：</p>
<pre><code><span class="function"><span class="title">len</span><span class="params">([], <span class="number">0</span>)</span></span>.
<span class="function"><span class="title">len</span><span class="params">([_|L], N)</span></span> :-
    <span class="function"><span class="title">len</span><span class="params">(L, N_)</span></span>,
    N is N_ + <span class="number">1</span>.
</code></pre></li>
<li><p>prolog里自带的list操作</p>
<p> 上面的的操作其实很多prolog已经写好了，直接调来用就可以了，这里给出我用的swi-prolog里的原生操作：</p>
<p> <img src="http://7xkwu7.com1.z0.glb.clouddn.com/prologlist.png" alt=""><br> 有点多，请读者自行在prolog下用help(谓词名)来获取实用信息。</p>
</li>
</ol>
<h5 id="list应用——全排列">list应用——全排列</h5><ul>
<li><p>方法一</p>
<pre><code><span class="function"><span class="title">permutation</span><span class="params">([], [])</span></span>.
<span class="function"><span class="title">permutation</span><span class="params">([X|L], P)</span></span> :-
    <span class="function"><span class="title">permutation</span><span class="params">(L, L1)</span></span>,
    <span class="function"><span class="title">insert</span><span class="params">(X, L1, P)</span></span>.
</code></pre></li>
<li><p>方法二</p>
<pre><code><span class="function"><span class="title">permutation</span><span class="params">([], [])</span></span>.
<span class="function"><span class="title">permutation_</span><span class="params">(L, [X|P])</span></span> :-
    <span class="function"><span class="title">delete</span><span class="params">(X, L, L1)</span></span>,
    <span class="function"><span class="title">permutation</span><span class="params">(L1,P)</span></span>
</code></pre></li>
</ul>
<p><em>Reference:</em></p>
<ol>
<li><em>Prolog Programming for Artificial Intelligence 4th edition - chapter 2/3</em> </li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本周的重点是AND/OR树、结构体和表。<br>通过AND/OR树，我们可以很好地理解Prolog的证明策略；<br>结构体是（一）里没有介绍过的类型，要注意与<strong>事实(facts)</strong>的区别；<br>List的构造与使用让我们真正感受到了在prolog里递归的力量，你会感叹设计递归的精妙与艰辛:p</p>]]>
    
    </summary>
    
      <category term="AI" scheme="http://xmhtech.me/tags/AI/"/>
    
      <category term="Prolog" scheme="http://xmhtech.me/tags/Prolog/"/>
    
      <category term="language" scheme="http://xmhtech.me/tags/language/"/>
    
      <category term="Tech" scheme="http://xmhtech.me/categories/Tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Prolog学习笔记（二）]]></title>
    <link href="http://xmhtech.me/2015/09/27/Prolog%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://xmhtech.me/2015/09/27/Prolog学习笔记（二）/</id>
    <published>2015-09-27T09:29:00.000Z</published>
    <updated>2015-09-27T09:45:08.000Z</updated>
    <content type="html"><![CDATA[<p>第三周：这周的主要内容是算数操作符，合一的概念还有跟踪和调试的方法。</p>
<p>这是第一个版本，时间仓促，没有怎么看书就发了出来，如有出错还请见谅，之后会对错误和遗漏进行修改。</p>
<a id="more"></a>
<h3 id="算数操作符(Arithmetic_Operators)">算数操作符(Arithmetic Operators)</h3><ol>
<li>操作符种类：<ul>
<li>运算操作符：+, -, *, /,^,mod（还可以使用div代表/，但是有所不同，/是实数除法，div是整数除法）</li>
<li>比较操作符：&lt;, &gt;, =&lt;, &gt;=, =:= (equals), =\= (not equals)</li>
</ul>
</li>
<li>操作符使用：表达式的返回值（可以这么解释吗）就是结果。<ul>
<li>前缀(prefix)：像用谓词一样使用即可；+(2,3)表达的就是2+3，还可以嵌套，这可以直观的用操作符树来表示；</li>
<li>中缀(infix)：和普通的计算公式相同相同；</li>
<li>后缀(postfix)：用的比较少；</li>
<li>自定义：可以通过自定义谓词来进行一些不同的计算过程，这周比较忙，这里就不再展开，先挖个坑<pre><code><span class="tag">&lt;我是坑&gt;</span>
</code></pre></li>
</ul>
</li>
<li>操作符优先级：^before mod before /, *, before +,-(和平时使用相同，括号的优先级最高)</li>
<li>计算结果：使用is才能够得到计算结果，不然只是一个表达式。<br> 对比：<pre><code>?- X = <span class="number">2</span> + <span class="number">3.</span>
X = <span class="number">2</span>+<span class="number">3.</span>
?- X is <span class="number">2</span> + <span class="number">3.</span>
X = <span class="number">5.</span>
</code></pre></li>
</ol>
<h3 id="合一(Unification)">合一(Unification)</h3><p>同一(Unify)概念是在 Prolog 背后的主要想法，它是逻辑学当中的一个的重要概念。《Prolog Programming for Artificial Intelligence》一书强调了出于效能的原因，在Prolog里用unification是不准确的，应该使用匹配(matching)，<br>    比如我们问Prolog：</p>
<pre><code> ?- X = f<span class="params">(X)</span>.
 这句匹配请求应该是成功还是失败？在逻辑中的合一<span class="params">(Unification)</span>，它应该是失败的，然而在prolog里就能实现。大家可以通过下面的跟踪感受一下：
 [trace]  ?- X = f<span class="params">(X)</span>, Y = X.
   Call: <span class="params">(<span class="number">8</span>)</span> _G951=f<span class="params">(_G951)</span> ? creep
   Exit: <span class="params">(<span class="number">8</span>)</span> f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(...)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>=f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(...)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span> ? creep
   Call: <span class="params">(<span class="number">8</span>)</span> _G956=f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(...)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span> ? creep
   Exit: <span class="params">(<span class="number">8</span>)</span> f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(...)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>=f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(...)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span> ? creep
X = Y, Y = f<span class="params">(Y)</span>.

[trace]  ?- X = f<span class="params">(X)</span>, Y =f<span class="params">(X)</span>.
   Call: <span class="params">(<span class="number">8</span>)</span> _G951=f<span class="params">(_G951)</span> ? creep
   Exit: <span class="params">(<span class="number">8</span>)</span> f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(...)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>=f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(...)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span> ? creep
   Call: <span class="params">(<span class="number">8</span>)</span> _G958=f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(...)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span> ? creep
   Exit: <span class="params">(<span class="number">8</span>)</span> f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(...)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>=f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(f<span class="params">(...)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span> ? creep
X = Y, Y = f<span class="params">(_S1)</span>, <span class="built_in">%</span> where
_S1 = f<span class="params">(_S1)</span>.
</code></pre><p>总而言之，它表示绑定变量的内容的机制并可以看作为一种只一次的(one-time)赋值。在 Prolog 中，这种操作用符号 “=” 来指示。</p>
<ol>
<li>在传统 Prolog 中，未实例化的变量 X —— 就是说在它上面以前没有进行合一，可以合一于一个原子、一个项、或另一个未实例化的变量，因此在效果上变成了它的别名。在很多现代 Prolog 方言和一阶逻辑演算中，变量<em>不能合一于包含它的项</em>；这叫做出现检查。</li>
<li>Prolog 原子只能合一于同一个原子。</li>
<li>类似的，项只能合一于另一个项，如果顶部函数符号和项的元数(arity)和这个项是一样的，并且参数可以同时合一。注意这是递归行为。<br>由于它的声明本性，一序列合一的次序(通常)是不重要的。</li>
</ol>
<p>注意： 在一阶逻辑的术语中，原子是基本命题而且其合一同 Prolog 项一样。<br>example:</p>
<pre><code><span class="number">1</span>. 这些是合一的：
     red = fred.         true
     ‘Hey you’ = ‘Hey you’.    true
     fred=X.            X=fred.
     X=Y.            Y=X. 
     <span class="function"><span class="title">foo</span><span class="params">(X)</span></span> = <span class="function"><span class="title">foo</span><span class="params">(bar)</span></span>.        X=bar.
     <span class="function"><span class="title">foo</span><span class="params">(N,N)</span></span> = <span class="function"><span class="title">foo</span><span class="params">(bar, X)</span></span>.        N=X, X=bar.
     <span class="function"><span class="title">foo</span><span class="params">(foo(bar)</span></span>) = <span class="function"><span class="title">foo</span><span class="params">(X)</span></span>        X=<span class="function"><span class="title">foo</span><span class="params">(bar)</span></span>
<span class="number">2</span>. 这些不是合一的：
     <span class="number">1</span> = <span class="function"><span class="title">sin</span><span class="params">(pi/<span class="number">2</span>)</span></span>.     <span class="comment">//1 is sin(pi/2).也是false，然而1 =:= sin(pi/2)是true</span>
     fred = jim.
     ‘Hey you’ = ‘Hey me’.
     <span class="function"><span class="title">frou</span><span class="params">(frou)</span></span> = <span class="function"><span class="title">f</span><span class="params">(frou)</span></span>.
     <span class="function"><span class="title">foo</span><span class="params">(bar)</span></span> = <span class="function"><span class="title">foo</span><span class="params">(bar,bar)</span></span>.
     <span class="function"><span class="title">foo</span><span class="params">(N,N)</span></span> = <span class="function"><span class="title">foo</span><span class="params">(bar,rab)</span></span>.
</code></pre><h3 id="其他命令：">其他命令：</h3><ul>
<li>跟踪(Trace)：<pre><code>?- <span class="keyword">trace</span>.<span class="comment">//开始</span>
[<span class="keyword">trace</span>] ?- notrace.<span class="comment">//结束</span>
</code></pre></li>
<li>调试(Debug)：<pre><code><span class="attr_selector">[trace]</span> ?<span class="tag">-</span> <span class="tag">notrace</span>.<span class="comment">//从跟踪结束</span>
<span class="attr_selector">[debug]</span> ?<span class="tag">-</span> <span class="tag">nodebug</span>.<span class="comment">//结束调试</span>
</code></pre></li>
</ul>
<p><em>Reference:</em></p>
<ol>
<li><em><a href="https://zh.wikipedia.org/wiki/合一" target="_blank" rel="external">https://zh.wikipedia.org/wiki/合一</a></em></li>
<li>_<a href="http://www.swi-prolog.org/pldoc/doc_for?object=manual" target="_blank" rel="external">http://www.swi-prolog.org/pldoc/doc_for?object=manual</a>_</li>
<li><em>Prolog Programming for Artificial Intelligence 4th edition - chapter 2、3</em></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>第三周：这周的主要内容是算数操作符，合一的概念还有跟踪和调试的方法。</p>
<p>这是第一个版本，时间仓促，没有怎么看书就发了出来，如有出错还请见谅，之后会对错误和遗漏进行修改。</p>]]>
    
    </summary>
    
      <category term="AI" scheme="http://xmhtech.me/tags/AI/"/>
    
      <category term="Prolog" scheme="http://xmhtech.me/tags/Prolog/"/>
    
      <category term="language" scheme="http://xmhtech.me/tags/language/"/>
    
      <category term="Tech" scheme="http://xmhtech.me/categories/Tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Homebrew安装使用总结]]></title>
    <link href="http://xmhtech.me/2015/09/19/Homebrew%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://xmhtech.me/2015/09/19/Homebrew安装使用总结/</id>
    <published>2015-09-19T14:29:16.000Z</published>
    <updated>2015-09-19T14:33:36.000Z</updated>
    <content type="html"><![CDATA[<p>homebrew是一个小型的，非商业性质的套件管理器。<br>它能够自动化安装库或者软件，并且自动安装其所需要的依赖（不同于MacPorts，尽量使用系统自带的库），定制简单，上手容易，更新及时，而且是直接装在 /usr/local 下，减少很多各种 PATH 环境变量的定义（简直是开发必备啊）。</p>
<a id="more"></a>
<h3 id="安装">安装</h3><p>终端输入</p>
<pre><code>ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/<span class="operator"><span class="keyword">install</span>/<span class="keyword">master</span>/<span class="keyword">install</span>)”//请去<span class="keyword">reference</span>中的官网去更新最新脚本</span>
</code></pre><p>若安装失败，请检查安装条件：</p>
<ol>
<li>Intel的芯片</li>
<li>系统是OS X 10.6及以上</li>
<li>Xcode开发工具（xcode-select –install）</li>
<li>已安装Bourne shell</li>
</ol>
<h3 id="卸载">卸载</h3><p>终端输入</p>
<pre><code>ruby <span class="operator">-e</span> <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)</span>"</span>
</code></pre><h3 id="常用命令">常用命令</h3><pre><code>brew <span class="keyword">help</span><span class="comment">//查看帮助信息</span>
brew <span class="keyword">search</span><span class="comment">//加要寻找的关键字</span>
brew install<span class="comment">//加要安装的包名称,安装最新的包及其依赖</span>
brew uninstall<span class="comment">//加要卸载的包名称，卸载它</span>
brew <span class="keyword">update</span><span class="comment">//升级自身</span>
brew <span class="keyword">list</span><span class="comment">//列出所有已安装的包名称</span>
brew outdated<span class="comment">//列出所有过时的包名称</span>
brew upgrade<span class="comment">//升级所有，加包名升级对应包（注意旧版本会保留）</span>
brew cleanup<span class="comment">//清除所有旧版本，-n用以查看信息，加包名清除对应包旧版本</span>
brew doctor<span class="comment">//诊断Homebrew存在的问题并给出建议</span>
brew info<span class="comment">//加包名查询对应信息，不加查询已安装的包的存储信息</span>
brew deps<span class="comment">//加包名查询对应依赖</span>
brew pin<span class="comment">//固定某一包的版本</span>
brew upin<span class="comment">//解除固定</span>
</code></pre><h3 id="二阶命令——brew_cask使用">二阶命令——brew cask使用</h3><p>安装cask</p>
<pre><code><span class="keyword">brew </span>install cask
</code></pre><p>之后就可以用brew cask 尽情地享受了~</p>
<pre><code>brew cask <span class="keyword">help</span><span class="comment">//查看帮助信息</span>
</code></pre><p>懒得一个个写了，这里粘贴出来，很多都和brew命令相同，不同的是用cask是用来安装.app的</p>
<pre><code>alfred     displays note about <span class="built_in">new</span> built-<span class="operator">in</span> alfred support
audit      verifies installability <span class="operator">of</span> Casks
cat        dump raw source <span class="operator">of</span> <span class="operator">the</span> given Cask <span class="built_in">to</span> <span class="operator">the</span> standard output
cleanup    cleans up cached downloads <span class="operator">and</span> tracker symlinks
<span class="built_in">create</span>     creates <span class="operator">the</span> given Cask <span class="operator">and</span> opens <span class="keyword">it</span> <span class="operator">in</span> <span class="operator">an</span> editor
doctor     checks <span class="keyword">for</span> configuration issues
edit       edits <span class="operator">the</span> given Cask
fetch      downloads Cask resources <span class="built_in">to</span> <span class="built_in">local</span> cache
home       opens <span class="operator">the</span> homepage <span class="operator">of</span> <span class="operator">the</span> given Cask
info       displays information about <span class="operator">the</span> given Cask
install    installs <span class="operator">the</span> given Cask
list       <span class="operator">with</span> no args, lists installed Casks; given installed Casks, lists staged <span class="built_in">files</span>
search     searches all known Casks
uninstall  uninstalls <span class="operator">the</span> given Cask
update     <span class="operator">a</span> synonym <span class="keyword">for</span> <span class="string">'brew update'</span>
zap        zaps all <span class="built_in">files</span> associated <span class="operator">with</span> <span class="operator">the</span> given Cask
</code></pre><h3 id="高阶用法">高阶用法</h3><pre><code>brew create//创建自己的Homebrew程式
brew edit//使用 <span class="variable">$EDITOR</span> 编辑!
</code></pre><p>详细用法可以参考：<a href="http://linfan.info/blog/2012/02/25/homebrew-installation-and-usage/" target="_blank" rel="external">http://linfan.info/blog/2012/02/25/homebrew-installation-and-usage/</a></p>
<p><em>Reference:</em></p>
<ol>
<li>官网地址： <a href="http://brew.sh" target="_blank" rel="external">http://brew.sh</a> </li>
<li>命令说明： <a href="https://github.com/Homebrew/homebrew/blob/master/share/doc/homebrew/Formula-Cookbook.md" target="_blank" rel="external">https://github.com/Homebrew/homebrew/blob/master/share/doc/homebrew/Formula-Cookbook.md</a></li>
<li>官方文档： <a href="https://github.com/Homebrew/homebrew/tree/master/share/doc" target="_blank" rel="external">https://github.com/Homebrew/homebrew/tree/master/share/doc</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>homebrew是一个小型的，非商业性质的套件管理器。<br>它能够自动化安装库或者软件，并且自动安装其所需要的依赖（不同于MacPorts，尽量使用系统自带的库），定制简单，上手容易，更新及时，而且是直接装在 /usr/local 下，减少很多各种 PATH 环境变量的定义（简直是开发必备啊）。</p>]]>
    
    </summary>
    
      <category term="develop" scheme="http://xmhtech.me/tags/develop/"/>
    
      <category term="mac" scheme="http://xmhtech.me/tags/mac/"/>
    
      <category term="tool" scheme="http://xmhtech.me/tags/tool/"/>
    
      <category term="Tech" scheme="http://xmhtech.me/categories/Tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Prolog学习笔记（一）]]></title>
    <link href="http://xmhtech.me/2015/09/18/Prolog%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://xmhtech.me/2015/09/18/Prolog学习笔记（一）/</id>
    <published>2015-09-18T13:18:00.000Z</published>
    <updated>2015-10-06T08:58:44.000Z</updated>
    <content type="html"><![CDATA[<h3 id="前言：">前言：</h3><p>选修了人工智能导论，要求的语言就是prolog，上了两节觉得这个语言还是挺有趣的，和以前的完全不是一个风格，这里整理一下自己初步的学习。</p>
<h3 id="Prolog简介：">Prolog简介：</h3><p>有别于一般的函数式语言，prolog的程序是基于谓词逻辑的理论。最基本的写法是定立对象与对象之间的关系，之后可以用询问目标的方式来查询各种对象之间的关系。系统会自动进行匹配及回溯，找出所询问的答案。</p>
<a id="more"></a>
<p>配置环境（macbook air）：</p>
<ol>
<li><p>直接用homebrew安装swi-prolog（没有安装的参见另一篇博文：<a href="http://xmhtech.me/2015/09/19/Homebrew安装使用总结/">Homebrew 安装使用总结</a>）</p>
<blockquote>
<p>What is swim-prolog?<br>它是一个prolog的解释器</p>
</blockquote>
<p> brew install homebrew/x11/swi-prolog</p>
</li>
<li><p>常用命令</p>
<pre><code>swipl <span class="comment">//调出主界面</span>
halt. <span class="comment">//退出，Control+D</span>
consult<span class="params">('’)</span>. <span class="comment">//</span>
reconsult<span class="params">()</span>.<span class="comment">//</span>
</code></pre></li>
</ol>
<p>基本语法</p>
<ol>
<li>谓词(predicate)：Prolog的基本组成元素，可以是一段程序、一个数据类型或是一种关系，由谓词名和参数组成，名称相同、参数不同的谓词是不同的谓词；</li>
<li>参数(argument)：<ul>
<li>变量(variables)<ul>
<li>总是以大写字母或者下划线开始</li>
<li>对于变量没有类型而言，它能选用任何值</li>
<li>变量有它自己的作用域，其他子句的同名变量不会继承上一子句的值</li>
<li>变量可以被看做是全称量词，读作“任给”<br>*常量(constants) :<ul>
<li>原子(atom)：<ul>
<li>以小写字母开头，由字母、数字和下划线组成</li>
<li>由特殊符号组成</li>
<li>由单引号围起来的句子</li>
</ul>
</li>
<li>数字(number)：绝对值小于某数的正数或负数</li>
</ul>
</li>
</ul>
</li>
<li>结构体(structure)：后面介绍</li>
</ul>
</li>
<li>规则(rules)<ul>
<li>结论(子句头)：由条件决定是否为真</li>
<li>条件(子句体)：一系列用逗号隔离的目标，逗号被认作为“与”</li>
</ul>
</li>
<li>事实(facts)：可以看做只有头的规则</li>
<li>问题(query)：可以看做只有体的规则</li>
<li>注释(comment)<ul>
<li>单行：%</li>
<li>多行：/<em>开始</em>/结束</li>
</ul>
</li>
</ol>
<p>其他：</p>
<pre><code><span class="number">1.</span> 询问时，分号的作用：使当前子句无效，继续搜索答案。
</code></pre><p><strong>Prolog是如何回答问题的?</strong></p>
<p>Prolog寻找证据的顺序正好与我们的推理相反，即执果索因，使用目标、规则、代换和当前目标来推导出新的目标，直到新目标恰好是简单事实时，给出答案。</p>
<p><em>Reference:</em></p>
<ol>
<li><em>Prolog Programming for Artificial Intelligence 4th edition - chapter 1</em></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="前言：">前言：</h3><p>选修了人工智能导论，要求的语言就是prolog，上了两节觉得这个语言还是挺有趣的，和以前的完全不是一个风格，这里整理一下自己初步的学习。</p>
<h3 id="Prolog简介：">Prolog简介：</h3><p>有别于一般的函数式语言，prolog的程序是基于谓词逻辑的理论。最基本的写法是定立对象与对象之间的关系，之后可以用询问目标的方式来查询各种对象之间的关系。系统会自动进行匹配及回溯，找出所询问的答案。</p>]]>
    
    </summary>
    
      <category term="AI" scheme="http://xmhtech.me/tags/AI/"/>
    
      <category term="Prolog" scheme="http://xmhtech.me/tags/Prolog/"/>
    
      <category term="language" scheme="http://xmhtech.me/tags/language/"/>
    
      <category term="Tech" scheme="http://xmhtech.me/categories/Tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TL-WR703N v1.7 刷OpenWrt（译）]]></title>
    <link href="http://xmhtech.me/2015/09/06/TL-WR703N%20v1.7%20%E5%88%B7OpenWrt%EF%BC%88%E8%AF%91%EF%BC%89/"/>
    <id>http://xmhtech.me/2015/09/06/TL-WR703N v1.7 刷OpenWrt（译）/</id>
    <published>2015-09-06T03:00:54.000Z</published>
    <updated>2015-09-06T03:04:03.000Z</updated>
    <content type="html"><![CDATA[<p>买了一台TP-Link wr703n准备刷OpenWrt用作开发，怎料官方挖了个大坑等我去跳——最新的官方固件封死网页刷机的渠道（据说是加了签名），又不会焊TTL的。。。幸好国外的大神已经给出了解决方案，亲测可行，替大家把原文翻译一下（有改动）。</p>
<a id="more"></a>
<p>原文出处：<a href="http://www.shadowandy.net/2015/03/flashing-tp-link-tl-wr703n-v1-7-to-openwrt.htm" target="_blank" rel="external">http://www.shadowandy.net/2015/03/flashing-tp-link-tl-wr703n-v1-7-to-openwrt.htm</a></p>
<h2 id="翻译水平有限大家将就看看哈，刷坏概不负责。">翻译水平有限大家将就看看哈，刷坏概不负责。</h2><h3 id="获得必要的材料">获得必要的材料</h3><p>将v1.7的TL-WR703N刷到OpenWrt，你需要：</p>
<ol>
<li>固件版本为3.17.1 Build 140120 Rel.56593n的TL-WR703N v1.7 </li>
<li>OpenWrt为TL-WR703N定制的固件 <a href="http://downloads.openwrt.org/barrier_breaker/14.07/ar71xx/generic/openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-factory.bin" target="_blank" rel="external">Download</a></li>
<li>cURL以发送 crafted http 请求 <a href="http://curl.haxx.se/download.html" target="_blank" rel="external">Download</a></li>
<li>dd 以拆分 OpenWrt 为 kernel 和 rootfs 镜像 <a href="http://www.chrysocome.net/dd" target="_blank" rel="external">Download</a></li>
<li>TFTP 服务器（建议32位）<a href="http://tftpd32.jounin.net/" target="_blank" rel="external">Download</a></li>
<li>一个命令行脚本来指导路由器执行刷机.你需要一个编辑器 (e.g. Notepad++) 来创建一个Unix风格的脚本</li>
<li>busybox 1.16.1 for mips <a href="http://www.busybox.net/downloads/binaries/1.16.1/" target="_blank" rel="external">Download</a></li>
</ol>
<h3 id="准备开发wr703n的材料">准备开发wr703n的材料</h3><ol>
<li><p>拆分 OpenWrt 为 kernel 和 rootfs 镜像</p>
<pre><code><span class="tag">dd</span> <span class="keyword">if</span>=openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-factory<span class="class">.bin</span> of=i1 bs=<span class="number">1</span> count=<span class="number">1048576</span>
<span class="tag">dd</span> <span class="keyword">if</span>=openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-factory<span class="class">.bin</span> of=i2 bs=<span class="number">1</span> skip=<span class="number">1048576</span>
</code></pre></li>
<li><p>在你的电脑上设置局域网接口</p>
</li>
</ol>
<p>命令行脚本(aa)是在和IP地址192.168.1.9沟通。你可以修改电脑的静态IP也可以修改命令行脚本里的地址，这取决于你！</p>
<h3 id="开始刷机">开始刷机</h3><ol>
<li><p>用必要的文件设置TFTP<br>现在你有以下四个文件：</p>
<ul>
<li>aa</li>
<li>i1</li>
<li>i2</li>
<li>busybox<br><strong>解压并执行</strong>TFTP服务器并且将操作根目录指向含有这四个文件的地方</li>
</ul>
</li>
<li><p>连接设备并且还原出厂设置（点击恢复出厂设置就好，不要干多余的事）</p>
</li>
<li><p>执行开发并升级<br> 在此之前，确认你电脑的静态IP为192.168.1.9</p>
<ol>
<li>将你的在命令行下的操作目录指向含有cURL的地方</li>
<li><p>依次执行以下三条命令</p>
<pre><code>curl -o - -b <span class="string">"tLargeScreenP=1; subType=pcSub; Authorization=Basic<span class="variable">%20YWRtaW46YWRtaW40Mg</span><span class="variable">%3D</span><span class="variable">%3D</span>; ChgPwdSubTag=true"</span> <span class="string">"http://192.168.1.1/"</span>
curl -o - -b <span class="string">"tLargeScreenP=1; subType=pcSub; Authorization=Basic<span class="variable">%20YWRtaW46YWRtaW40Mg</span><span class="variable">%3D</span><span class="variable">%3D</span>; ChgPwdSubTag="</span> --referer <span class="string">"http://192.168.1.1/userRpm/ParentCtrlRpm.htm"</span> <span class="string">"http://192.168.1.1/userRpm/ParentCtrlRpm.htm?ctrl_enable=1&amp;parent_mac_addr=00-00-00-00-00-02&amp;Page=1"</span>
curl -o - -b <span class="string">"tLargeScreenP=1; subType=pcSub; Authorization=Basic<span class="variable">%20YWRtaW46YWRtaW40Mg</span><span class="variable">%3D</span><span class="variable">%3D</span>; ChgPwdSubTag="</span> --referer <span class="string">"http://192.168.1.1/userRpm/ParentCtrlRpm.htm?Modify=0&amp;Page=1"</span> <span class="string">"http://192.168.1.1/userRpm/ParentCtrlRpm.htm?child_mac=00-00-00-00-00-01&amp;lan_lists=888&amp;url_comment=test&amp;url_0=;cd<span class="variable">%20</span>/tmp;&amp;url_1=;tftp<span class="variable">%20</span>-gl<span class="variable">%20aa</span><span class="variable">%20192</span>.168.1.9;&amp;url_2=;sh<span class="variable">%20aa</span>;&amp;url_3=&amp;url_4=&amp;url_5=&amp;url_6=&amp;url_7=&amp;scheds_lists=255&amp;enable=1&amp;Changed=1&amp;SelIndex=0&amp;Page=1&amp;rule_mode=0&amp;Save=<span class="variable">%B1</span><span class="variable">%A3</span>+<span class="variable">%B4</span><span class="variable">%E6</span>"</span>
</code></pre><p>判断命令是否执行成功：</p>
</li>
</ol>
<ul>
<li>如果命令一成功，登陆密码被修改为”admin42”</li>
<li>如果命令二成功，I can see the new parental item is added and enabled.(没看懂orz)</li>
<li><p>但是如果命令三成功，看起来没有任何事情发生（命令三有些慢，请不要慌）</p>
<p>备注：在过程中千万不要断开路由器的电源，否则你的路由器很有可能变砖！！！</p>
</li>
</ul>
</li>
<li>当路由器不再闪烁时，在浏览器输入192.168.1.1登陆Openwrt。</li>
<li>享受你的 TL-WR703N v1.7 吧</li>
</ol>
<p>这里是我刷机用过的工具和做好的材料，解压后使用——<a href="http://pan.baidu.com/share/link?shareid=3048068689&amp;uk=3694274917" target="_blank" rel="external">度盘</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>买了一台TP-Link wr703n准备刷OpenWrt用作开发，怎料官方挖了个大坑等我去跳——最新的官方固件封死网页刷机的渠道（据说是加了签名），又不会焊TTL的。。。幸好国外的大神已经给出了解决方案，亲测可行，替大家把原文翻译一下（有改动）。</p>]]>
    
    </summary>
    
      <category term="OpenWrt" scheme="http://xmhtech.me/tags/OpenWrt/"/>
    
      <category term="Translation" scheme="http://xmhtech.me/tags/Translation/"/>
    
      <category term="router" scheme="http://xmhtech.me/tags/router/"/>
    
      <category term="Tech" scheme="http://xmhtech.me/categories/Tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初识SDN]]></title>
    <link href="http://xmhtech.me/2015/09/05/%E5%88%9D%E8%AF%86SDN/"/>
    <id>http://xmhtech.me/2015/09/05/初识SDN/</id>
    <published>2015-09-05T02:51:23.000Z</published>
    <updated>2015-10-06T04:23:10.000Z</updated>
    <content type="html"><![CDATA[<p><strong>SDN</strong>是一种为了解决传统网络中各种问题，比如管理困难、维护困难、拓展性差、灵活性差等，而出现的<strong>新型</strong>的<em><strong>网络架构</strong></em>。它的核心特征是实现了控制平面和数据平面的分离、控制逻辑集中和网络可编程。它的意义在于淡化底层设备的作用，让网络硬件的设计更加简单通用，打破“<strong>厂商锁定</strong>”，并且在这之上建立一个开放的网络操作系统，让开发者进入网络服务开发的门槛更低，建立起一个大三层网络生态系统，激发网络<em><strong>创新</strong></em>，给用户带来更好的使用体验。</p>
<a id="more"></a>
<h3 id="架构">架构</h3><p><img src="http://7xkwu7.com1.z0.glb.clouddn.com/sdnsdn-3layers-2.gif" alt=""><br><em>图片出自ONF</em></p>
<p><a href="https://www.opennetworking.org" target="_blank" rel="external">ONF</a>提出的典型架构分为三层（从上到下依次是）：</p>
<ul>
<li>应用层（应用平面）</li>
<li>控制层（控制平面）</li>
<li>基础设施层（数据平面）</li>
</ul>
<p><em>备注：连接底下两层的被称为南向接口，连接顶上两层则被称为北向接口，控制层内部的连接被称为东西向接口。</em></p>
<h3 id="核心特征">核心特征</h3><ul>
<li><p>控制逻辑集中：传统网络中分散的控制在SDN网络中被集中了起来，并且获得了空前的对全网的信息掌控，在此基础上很多复杂的操作都将被简化。</p>
</li>
<li><p>网络可编程 (programmability)：SDN网络中的北向接口，屏蔽了下层网络的细节，兼容多种高级语言，降低了开发者进入网络开发领域的门槛。</p>
</li>
<li><p>数据控制分离：传统网络体系里数据平面和控制平面都是分布式的，相互之间通过协议协作，但是这种分布式的网络控制不可避免地将会带来管理和维护的麻烦，而且出现问题可能也是连动式地，对于故障的定位也是一个大问题。SDN网络在这种分布式网络中分离出了控制部分，让所有上层的控制决策都由一个远端的控制器或者控制集群来下发。</p>
</li>
</ul>
<h3 id="各层简介">各层简介</h3><h4 id="（一）数据平面">（一）数据平面</h4><p>传统交换设备的功能架构包含了控制平面和数据平面，在物理上是紧耦合的，各种转发设备均与协议相关。SDN数据平面的交换设备专注于高速转发数据分组，转发决策由南向接口下发，实现了硬件设计的精简化，提升了效率。</p>
<p>SDN交换机设计：</p>
<ol>
<li>转发决策(Forwarding Decision)<br>数据分组进入交换机后，先与流表进行匹配查找，匹配成功则执行相应处理动作，失败则上交控制器由之决策，流程依赖于内部的SDN交换芯片，也是设备速率的瓶颈所在。</li>
<li>背板转发(Backplane)<br>交换机通过背板将各个端口连接，经由背板从输入端口转发到目的端口，为保证顺序，这里有个队列，队列满数据可能会被丢弃。</li>
<li>输出链路调度(Output Link Scheduling)<br>当数据分组到达SDN交换机的设备出端口后，在队列里等待，直到它被发出到相应的交换机输出链路上。</li>
</ol>
<h4 id="（二）控制平面">（二）控制平面</h4><p>控制平面向上提供应用接口，向下指挥硬件转发，是整个SDN架构中最核心的部分。<br>类似于计算机的操作系统，设计SDN控制器的体系可以以之为参考。<br>控制器（Controller）是控制平面的核心组件，它是一个运行在服务器上的软件程序，可以用不同的语言运行在不同的操作系统上。<br>SDN控制器的设计多种多样，但一般要考虑到以下几个方面：</p>
<ol>
<li>北向接口：不同的控制器北向接口差异可以很大；</li>
<li>南向接口：不同于OpenFlow控制器，SDN控制器可以是更加灵活的，而已支持其他南向接口甚至私有接口，这也是设备制造商差异化服务的体现；</li>
<li>东西向接口（控制方式）：单点控制存在可拓展性、可靠性、安全性等一系列问题，所以必须要设计分布式的控制器集群，通常这个集群会有一个Master；</li>
<li>网络功能：除了北向接口，控制器还可以提供不同的网络功能，一些服务和应用可以内置在系统里（像手机的预装软件，这也是厂商在疯狂争夺控制器市场的重要原因之一）；</li>
<li>可扩展性：从内部看要考虑到增删网络功能模块对系统的稳定性，从外部看要考虑到对不同使用场景的适应能力；</li>
<li>安全性：系统级别的安全防御是很有必要的，在这一层要能够拦截下绝大部分网络攻击；</li>
<li>可靠性：要考虑到集群某一个或几个控制器故障或者遭受攻击的情况，要立刻启动应急机制，像是备份控制器。</li>
</ol>
<h4 id="（三）应用平面">（三）应用平面</h4><p>SDN应用平面正是SDN体现其创新平台作用的地方，与传统网络相比，SDN网络将拥有更强的智能型，动态控制性和可编程性。<br>在当前主流SDN网络应用平面上，主要有以下三种类型的应用：</p>
<ol>
<li>资源管理平台<br>  在资源管理平台上整合SDN交付的网络控制能力是为了满足云计算资源调配自动化的需求，那些由标准步骤构成的流程最适合用专门的脚本来模拟反复，资源管理平台以软件的形式实现了对网络资源包括计算、存储和网络的协同交付。所以，SDN也是助力云计算发展的一大利器；</li>
<li>软件定义的应用交付<br>  网络上一直存在着改善网络服务的性能和体验的应用，例如Web安全、访问控制、负载均衡、应用加速、WAN优化、入侵检测等。它们在网络安全、管理方面发挥了重要作用，然而随着SDN的发展，这些原本集成在各层硬件上的服务也可以以软件形式被部署在服务器上，还可以是和控制器共用一个服务器，由于控制器具备全网视角，集中化的网络管理能力也从另一个侧面强化了这些网络应用的作用方式和范围。但是也要注意这会增加控制器的工作量以及网络受攻击的风险，同样的道理，这种影响也是全网级别的。</li>
<li>创新网络业务<br>  这类应用形式并不统一，但它一定是一些传统网络难以胜任而在SDN环境下能获得良好支持的一些软件。这也正是SDN网络未来的发展所在。</li>
</ol>
<h3 id="接口技术">接口技术</h3><ul>
<li><p>南向接口：SDN控制器通过南向接口对SDN交换机进行集中管理，目前OpenFlow协议是由ONF唯一确定的控制器标准南向接口（还有与之配套的OF-CONFIG配置协议，用于远程配置OpenFlow交换机），也有一些其他的接口。</p>
</li>
<li><p>北向接口：网络应用开发者可以利用北向接口，以软件编程的形式实现对网络资源的调用，灵活性强。</p>
</li>
<li><p>东西向接口：控制平面如果采用单点设计难以应对各种网络问题，而且存在安全性、可靠性、扩展性等诸多问题，所以采用控制器集群式设计是较为合理的做法，控制器集群的沟通协作就需要一个新的规范——这就是东西向接口。</p>
</li>
</ul>
<p><em>Reference</em></p>
<ol>
<li>《软件定义网络——核心原理与应用实践》，人民邮电出版社，黄韬，刘江，魏亮，张娇，刘韵洁；  </li>
<li>《SDN核心技术剖析和实战指南》，电子工业出版社，雷葆华，王峰，王茜，王和宇等；  </li>
<li>《深度解析SDN——利益、战略、技术、实践》，电子工业出版社，张卫峰。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>SDN</strong>是一种为了解决传统网络中各种问题，比如管理困难、维护困难、拓展性差、灵活性差等，而出现的<strong>新型</strong>的<em><strong>网络架构</strong></em>。它的核心特征是实现了控制平面和数据平面的分离、控制逻辑集中和网络可编程。它的意义在于淡化底层设备的作用，让网络硬件的设计更加简单通用，打破“<strong>厂商锁定</strong>”，并且在这之上建立一个开放的网络操作系统，让开发者进入网络服务开发的门槛更低，建立起一个大三层网络生态系统，激发网络<em><strong>创新</strong></em>，给用户带来更好的使用体验。</p>]]>
    
    </summary>
    
      <category term="Network" scheme="http://xmhtech.me/tags/Network/"/>
    
      <category term="SDN" scheme="http://xmhtech.me/tags/SDN/"/>
    
      <category term="summary" scheme="http://xmhtech.me/tags/summary/"/>
    
      <category term="Sci" scheme="http://xmhtech.me/categories/Sci/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[网络信息的检索与利用]]></title>
    <link href="http://xmhtech.me/2015/08/08/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E7%9A%84%E6%A3%80%E7%B4%A2%E4%B8%8E%E5%88%A9%E7%94%A8/"/>
    <id>http://xmhtech.me/2015/08/08/网络信息的检索与利用/</id>
    <published>2015-08-08T14:01:35.000Z</published>
    <updated>2015-08-08T14:03:48.000Z</updated>
    <content type="html"><![CDATA[<a id="more"></a>
]]></content>
    <summary type="html">
    <![CDATA[<a id="more"></a>
]]>
    </summary>
    
      <category term="book" scheme="http://xmhtech.me/tags/book/"/>
    
      <category term="info" scheme="http://xmhtech.me/tags/info/"/>
    
      <category term="Tech" scheme="http://xmhtech.me/categories/Tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[搜索进阶]]></title>
    <link href="http://xmhtech.me/2015/08/08/%E6%90%9C%E7%B4%A2%E8%BF%9B%E9%98%B6/"/>
    <id>http://xmhtech.me/2015/08/08/搜索进阶/</id>
    <published>2015-08-08T14:00:50.000Z</published>
    <updated>2015-10-06T04:20:31.000Z</updated>
    <content type="html"><![CDATA[<a id="more"></a>
]]></content>
    <summary type="html">
    <![CDATA[<a id="more"></a>
]]>
    </summary>
    
      <category term="Resource" scheme="http://xmhtech.me/tags/Resource/"/>
    
      <category term="info" scheme="http://xmhtech.me/tags/info/"/>
    
      <category term="Others" scheme="http://xmhtech.me/categories/Others/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从搜索引擎谈起]]></title>
    <link href="http://xmhtech.me/2015/08/07/%E4%BB%8E%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E8%B0%88%E8%B5%B7/"/>
    <id>http://xmhtech.me/2015/08/07/从搜索引擎谈起/</id>
    <published>2015-08-07T12:31:08.000Z</published>
    <updated>2015-08-19T14:23:33.000Z</updated>
    <content type="html"><![CDATA[<p>心血来潮想整理下一些关于搜索的奇技淫巧。在这个信息爆炸的时代不会用搜索不仅仅是一件令人遗憾的事情，可能会对你的生活都造成影响。能够快速、准确地利用搜索引擎找到自己想要的信息和资源，也是一件令人骄傲的事。</p>
<p>不过搜出来的很多技巧倒是让我大吃一惊，在这里分享出来。</p>
<a id="more"></a>
<h2 id="你所不知道的谷歌的用法">你所不知道的谷歌的用法</h2><p>哦，首先你得学会科学上网，等哪天我再写一篇科学上网方法的汇总。<br>如果实在不会，可以尝试<a href="http://www.gfsoso.com" target="_blank" rel="external">谷粉搜搜</a>  </p>
<p>把以下的字符组合加在关键词(句)前：</p>
<ul>
<li><code>&quot; &quot;</code>以整个短语为关键字(完全匹配搜索)，而不是拆开</li>
<li><code>-</code>排除某个关键字的搜索结果</li>
<li><code>~</code>同时搜索它后面的近义词</li>
<li><code>..</code>显示指定年份你时间段内的搜索结果<br>  例如 ：2013..2015会搜索2013年到2015年的所有结果</li>
<li><code>site:</code>只搜索某个网站的页面</li>
<li><code>filetype:</code>只搜索指定后缀的文件</li>
<li><code>intitle:</code>只显示标题中含有该关键字的结果</li>
<li><code>allintitle:</code>搜索返回的是页面标题中包含多组关键词的文件</li>
<li><code>inurl:</code>用于搜索查询词出现在url中的页面</li>
<li><code>allinurl:</code>搜索返回的是出现在url中包含多组关键词的文件</li>
<li><code>inanchor:</code>指令返回的结果是导入链接锚文字中包含搜索词的页面</li>
<li><code>related:</code>返回的结果是与某个网站有关的页面(这个有关该怎么定义就不大清楚了，一般认为指的是有共同外部链接的网站)</li>
<li><code>*</code>用于代替任何字符，或者应该说是单词</li>
<li><code>author:</code>搜索作者名字里含关键字的文章——谷歌学术</li>
<li><code>&quot; &quot;</code>可以在引号里输入作者的全名或者缩写——谷歌学术</li>
<li><code>OR</code>用在两个关键词中间搜索任意一个出现的网页</li>
<li><code>link:</code>搜索含有某个链接的网页</li>
<li><code>cache:</code>用了搜索谷歌服务器上的缓存，用于查找死链</li>
<li><code>info:</code>提供cache、link、related和完全包含该信息的网页</li>
</ul>
<p>以上基本的语法，组合起来会有更多更多奇妙的效果</p>
<h2 id="除了谷歌，我们还有什么">除了谷歌，我们还有什么</h2><p>首先祭出大杀器：<br><a href="http://so.chongbuluo.com" target="_blank" rel="external">快搜-搜索快人一步</a><br>这个亦可以看看吧<br><a href="http://s.f2do.com" target="_blank" rel="external">多维搜索 - 同时搜索多个维度的数据</a></p>
<p>以下搜索引擎其实只要了解一些就可以通过谷歌搜索出来，相当于二阶搜索的技巧</p>
<p><a href="www.baidu.com">百度</a><br><a href="www.google.com">谷歌</a><br><a href="www.bing.com">必应</a><br><a href="https://www.sogou.com" target="_blank" rel="external">搜狗</a><br><a href="http://www.haosou.com" target="_blank" rel="external">好搜</a>——360的搜索产品 </p>
<p><a href="https://www.taobao.com" target="_blank" rel="external">淘宝</a><br><a href="http://weixin.sogou.com" target="_blank" rel="external">微信搜索</a>——搜狗微信搜索<br><a href="http://s.weibo.com" target="_blank" rel="external">微博搜索</a></p>
<p><a href="https://scholar.google.com" target="_blank" rel="external">谷歌学术</a><br><a href="http://xueshu.baidu.com" target="_blank" rel="external">百度学术</a><br><a href="">超星发现</a>  </p>
<p><a href="http://so.baiduyun.me" target="_blank" rel="external">百度网盘</a>  </p>
<p><a href="http://www.soopat.com" target="_blank" rel="external">soopat</a>——搜索专利的一个网站<br><a href="https://www.quora.com" target="_blank" rel="external">quora</a><br><a href="http://www.wolframalpha.com" target="_blank" rel="external">wolframalpha</a></p>
<h2 id="搜索的自我提升">搜索的自我提升</h2><p>随着搜索次数的增加，搜索的效率是会不断提升的，要学会<strong>复盘</strong>，保存之前搜索的结果，试试有没有更快更准确的别的方法。很多时候之前搜到的信息也能够作为你下一次搜索的参考来实现关键字优化（应该说是某种矫正吗）<br>如果没有搜到，去思考为什么会搜不到，是不是应该搜索，是不是应该在这里搜索…</p>
<h2 id="Small_Tips">Small Tips</h2><ol>
<li><p>更换语言搜索  </p>
<blockquote>
<p>曾经做过女性产品，需要性感美女照片，国内美女要考虑肖像权。所以我就把＂性感美女    ＂这个关键词换成其他国家语言，拿到Google上搜，法国，英国，韩国，日本，我想要的    还真的都有，很好用。<br> 当然，用日文搜，往往还有意外收获。</p>
</blockquote>
<p> 但我想这个只适用于图片音乐什么的吧，不然你搜到了也看不懂。（突然觉得那种会好几种语言的好牛逼，获取信息的竞赛他们在一开始就领先于我们，但转念一想自己其实连中文和英文的信息都不可能吃透，会更多的语言也许也是烦恼:p）<br> 不过最好的应该还是用英文关键字检索，世界上大多数信息还是集中在英文网页中的。</p>
</li>
<li><p>积累关键字——每个专业领域内都有一些专业术语，而这些术语出现在媒体或口语中都是俗称，要想查到高质量的结果，就要有把术语和俗称进行转换的能力。另外，经过长期检验，有一些专家和记者非常靠谱，在搜索问题时同时加入他们的名字，得到的结果质量会高很多。</p>
</li>
<li>找出<strong>背后</strong>的脸——灵活使用此技巧,你可以过滤Google的图片搜索,使之只出现人的图像.这有什么用?这么说吧,如果你要找一个有名的人的图片,但是与之同名的产品,公司或者地理位置什么的会使你困扰,这个小技巧能让你更得心应手.想使用这个方法,你只需要在标准图片搜索之后在URL地址后面加上后缀&amp;imgtype=face  </li>
<li>浏览全球范围内的公开摄像头——你可以通过搜索Google随机地浏览全球范围内的摄像头流媒体.这可能不是最有效的Google技巧,但却是最有趣的!(作者:你可能需要立即安装一个ActiveX控件或者Java运行环境,以允许你的浏览器获取这些视频流格式)</li>
<li>在谷歌/必应里搜索百度网盘(<strong>网站积累</strong>)——加site:pan.baidu.com，将这个技巧泛化可以得到很多应用，但是首先你得知道site:后面要填什么，所以平时要注意网站的积累，这个博客也会不定期更新，我会把我所知道最新最有用的网站贴给大家。(也可以是<code>关键字 + &quot;(网址)&quot;</code>的形式)<br> (1) site:evernote.com/pub/——利用这种方法可以搜索到无私贡献出自己高质量笔记本的大牛们的私活，绝赞好评！！！（site:evernote.com/shard/——单个笔记）<br> (2) </li>
</ol>
<h2 id="反思">反思</h2><p>回到最初的问题，滥用搜索引擎真的好吗？且不说搜索引擎带给我们的答案是否正确，作为工具，它确实给我们带来了许多的便利，但同时我们也要注意使用这个工具所带来的潜在风险。</p>
<ul>
<li>钝化思维：很多时候，我们自己不能解决的问题，问一下搜索引擎就好了，午饭吃什么，生病了要吃什么，什么衣服比较流行诸如此类生活化问题搜索引擎也会帮你找到相关网页让你得到你可能想要的答案，可是这些问题真的值得上搜索引擎问嘛？或者问搜索引擎真的对吗？</li>
<li>信息质量良莠不齐：搜索引擎不会告诉你哪些回答是对的哪些回答是错的，而且也不排除你会把对的答案用在了错的地方，对于网络上浩如烟海的信息资源，如何辨别衡量他们的质量便是一个很大的问题，不过像是某度的知道就给出了对回答的评价机制，让网友来辨别答案的真假，这在一定程度上给了我们更多的信息去辨别。</li>
<li>效率问题：有的时候你费尽去搜索，得不到答案也是一件很苦恼的事情，虽然总好过得到了一个错误的答案，但你总归把时间浪费在了这上面，如果说你能得到一些促进你得到结果的idea也算还好，什么都没得到只顾搜索那就违背了我们使用搜索引擎的初衷。</li>
</ul>
<p>所以在使用搜索引擎前要好好衡量以上的几点因素，不要到最后成为一个离开搜素引擎就没用了的废物。</p>
<h2 id="总结">总结</h2><p>突然觉得以前一搜就搜出几千万的结果然后没翻几页就决定结果的行为甚是草率，如何精确、准确定位自己所需要的资源或信息，我还有很长一段路要走。  </p>
<h4 id="后记：有针对地去寻找资源和信息——不定期更新">后记：有针对地去寻找资源和信息——不定期更新</h4><p>很多时候搜索引擎显得并不是那么好用，有些高质量的论坛、网站里面相当于已经帮你做好了一次筛选，虽然搜出来可能不是几百几千万结果，但这些地方也许有更多的可能有你想要的答案，因为它已经帮你筛选过了，而且得到的结果的准确率往往也会高许多。</p>
<ol>
<li>书籍</li>
<li>图片<ul>
<li>素材</li>
<li>壁纸</li>
<li>以图搜图<ul>
<li><a href="http://tineye.com/" target="_blank" rel="external">Tineye</a></li>
<li><a href="http://www.gazopa.com/" target="_blank" rel="external">GazoPa</a></li>
<li><a href="http://similar-images.googlelabs.com/" target="_blank" rel="external">GoogleLab</a></li>
</ul>
</li>
</ul>
</li>
<li>音乐</li>
<li>视频</li>
<li>软件<ul>
<li>Mobile<ul>
<li>iOS</li>
<li>Android</li>
<li>Windows</li>
</ul>
</li>
<li>PC<ul>
<li>OS X</li>
<li>Windows</li>
<li>Linux</li>
</ul>
</li>
<li></li>
</ul>
</li>
<li>种子</li>
<li>人<ul>
<li><a href="http://www.bing.com/yxl?mkt=zh-CN" target="_blank" rel="external">必应影响力</a></li>
</ul>
</li>
<li>学术  <ul>
<li><a href="http://dir.cnki.net" target="_blank" rel="external">学术网站大全</a>——堪称学术的集大成导航</li>
<li><a href="http://www.nature.com" target="_blank" rel="external">Nature</a></li>
<li><a href="https://www.acm.org" target="_blank" rel="external">ACM</a>——The world’s largest educational and scientific computing society</li>
<li></li>
</ul>
</li>
<li>代码<ul>
<li><a href="https://github.com/search" target="_blank" rel="external">Code Search</a></li>
<li><a href="http://www.codase.com" target="_blank" rel="external">Codase</a></li>
<li><a href="http://sourceforge.net" target="_blank" rel="external">Sourceforge</a></li>
</ul>
</li>
<li>资讯</li>
<li>高质量论坛/社区/问答类网站<ul>
<li><a href="http://www.zhihu.com" target="_blank" rel="external">知乎</a></li>
<li><a href="http://www.quora.com" target="_blank" rel="external">Quora</a></li>
</ul>
</li>
<li>公开课<ul>
<li><a href="https://www.coursera.org" target="_blank" rel="external">coursera</a></li>
<li><a href="https://www.udacity.com" target="_blank" rel="external">udacity</a></li>
<li><a href="https://www.edx.org" target="_blank" rel="external">edX</a></li>
<li><a href="http://www.imooc.com" target="_blank" rel="external">慕课网</a></li>
<li><a href="http://www.duobei.com" target="_blank" rel="external">多贝公开课</a></li>
<li><a href="http://study.163.com" target="_blank" rel="external">网易云课堂</a></li>
</ul>
</li>
<li>资源下载<ul>
<li><a href="http://down.51cto.com" target="_blank" rel="external">51CTO</a>——IT资料</li>
</ul>
</li>
</ol>
<h5 id="参考">参考</h5><ol>
<li><a href="http://www.zhihu.com/question/20161362" target="_blank" rel="external">知乎：如何用好 Google 等搜索引擎？</a></li>
<li><a href="http://www.zhihu.com/question/23233662" target="_blank" rel="external">知乎：你有什么在网上搜索东西的神搜索技巧？</a></li>
<li><a href="http://www.zhihu.com/question/20251786" target="_blank" rel="external">知乎：有哪些特殊的搜索引擎</a></li>
</ol>
<p>下一篇<code>搜索进阶</code>我将会结合自己的想法和前辈的经验，总结一下搜索的步骤。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>心血来潮想整理下一些关于搜索的奇技淫巧。在这个信息爆炸的时代不会用搜索不仅仅是一件令人遗憾的事情，可能会对你的生活都造成影响。能够快速、准确地利用搜索引擎找到自己想要的信息和资源，也是一件令人骄傲的事。</p>
<p>不过搜出来的很多技巧倒是让我大吃一惊，在这里分享出来。</p>]]>
    
    </summary>
    
      <category term="Google" scheme="http://xmhtech.me/tags/Google/"/>
    
      <category term="Resource" scheme="http://xmhtech.me/tags/Resource/"/>
    
      <category term="info" scheme="http://xmhtech.me/tags/info/"/>
    
      <category term="Others" scheme="http://xmhtech.me/categories/Others/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Markdown 学习]]></title>
    <link href="http://xmhtech.me/2015/08/05/Markdown-%E5%AD%A6%E4%B9%A0/"/>
    <id>http://xmhtech.me/2015/08/05/Markdown-学习/</id>
    <published>2015-08-05T12:22:48.000Z</published>
    <updated>2015-08-08T08:11:48.000Z</updated>
    <content type="html"><![CDATA[<p>刚建好自己的小窝，第一篇正式的博文记录了自己学习的Markdown语法，毕竟以后都要使用它来写博客，大家多多指教。<br><a id="more"></a></p>
<h3 id="斜体设置">斜体设置</h3><p>你需要在需要斜体的部分前后加上一个underscore（下划线），像<em>这样</em>。</p>
<h3 id="粗体设置">粗体设置</h3><p>你需要在需要粗体的部分都加上两个asterisks（星号）,像<strong>这样</strong>。<br>这里有个小插曲，我发现加一个asterisks是<em>这样</em>，也是斜体。</p>
<p><strong>以上两种语法的组合不分先后.</strong></p>
<h3 id="行内代码">行内代码</h3><p>你需要使用反引号 (`)(在键盘上位于1的左边)把文字括起来来表示<code>行内代码</code></p>
<h3 id="标题设置">标题设置</h3><p>你需要在你的标题前面加若干个连续的hash mark（俗称井号），井号越多字体越小，最多六个，像这样：</p>
<h1 id="重要的事情说三遍">重要的事情说三遍</h1><h2 id="重要的事情说三遍-1">重要的事情说三遍</h2><h3 id="重要的事情说三遍-2">重要的事情说三遍</h3><h4 id="因为很重要所以再说三遍">因为很重要所以再说三遍</h4><h5 id="因为很重要所以再说三遍-1">因为很重要所以再说三遍</h5><h6 id="因为很重要所以再说三遍-2">因为很重要所以再说三遍</h6><pre><code>注意<span class="built_in">hash</span> mark只有在行首才有用，否则会失去它本身的作用而被无情地显示出来T_T
</code></pre><p>只要hash mark在行首，对后面的内容部分你可以随意地用上面介绍的两个语法让文字<em>变斜</em>，或者<strong>加粗</strong>。<br>    还有一个要提醒大家的地方就是——<strong>慎用</strong>一号标题和六号标题！！！</p>
<p>以上的标题设置我们称之为<strong>类atx</strong>形式的语法，接下来要介绍另一种局限性比较大的标题设置语法——<strong>类Setext</strong>形式语法。<br>类 Setext 形式是用底线的形式，利用 =（最高阶标题）和 -（第二阶标题），任意数量的 = 和 - 加在要作为标题的文本下方即可。</p>
<h3 id="分隔线">分隔线</h3><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。</p>
<h3 id="网页链接">网页链接</h3><p>在Markdown的语法里有两种链接网页的方式：</p>
<h5 id="第一种：Inline_Link">第一种：Inline Link</h5><p>在你想显示的文本外边框起brackets（方括号），紧接着在后边用parenthesis（圆括号）框起这段文字指向的链接，例如：<br>    <a href="http://xmhtech.me">千万不要点这里</a><br>Remark:  </p>
<ul>
<li>brackets和parenthesis都是半角的;</li>
<li>还有前两种语法对brackets里的内容也适用;</li>
<li>标题里也可以添加链接;</li>
</ul>
<h5 id="第二种：Reference_Link">第二种：Reference Link</h5><p>正如Reference的意思，这种链接网页的方式实际上是对文档内其他位置的链接的引用。它的语法是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：</p>
<pre><code>This is [<span class="link_label">an example</span>][<span class="link_reference">id</span>] reference-style link.
</code></pre><p>你也可以选择性地在两个方括号中间加上一个空格：</p>
<pre><code>This <span class="keyword">is</span> [an example] [<span class="property">id</span>]<span class="keyword">reference</span>-style link.
</code></pre><p>接着，在文件的任意处，你可以把这个标记的链接内容定义出来：</p>
<pre><code><span class="attr_selector">[id]</span>: <span class="rule"><span class="attribute">http</span>:<span class="value">//example.com/  <span class="string">"Optional Title Here"</span></span></span>
</code></pre><p>链接内容定义的形式为：</p>
<ul>
<li>方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字</li>
<li>接着一个冒号</li>
<li>接着一个以上的空格或制表符</li>
<li>接着链接的网址</li>
<li>选择性地接着 title 内容，可以用单引号、双引号或是括弧包着</li>
</ul>
<p>下面这三种链接的定义都是相同：</p>
<pre><code>[<span class="link_reference">foo</span>]:<span class="link_url"> http://example.com/  "Optional Title Here"</span>
[<span class="link_reference">foo</span>]:<span class="link_url"> http://example.com/  'Optional Title Here'</span>
[<span class="link_reference">foo</span>]:<span class="link_url"> http://example.com/  (Optional Title Here)</span>
</code></pre><p>这样做的一个好处是，当多个link指向同一个网址时，更新时只需要修改一个地方，方便也不容易忘记。</p>
<h5 id="第三种：Auto_Link">第三种：Auto Link</h5><p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样。</p>
<h3 id="插入图片">插入图片</h3><p>当你已经学会插入网页链接时，插入图片也不是什么难事了，插入图片也有两种方式，要做的只是把先前网页链接的部分换成图片的外链地址，为了区别于网站链接而将图片显示出来，在方括号前面加上一个exclamation point（叹号）即可<br><img src="http://7xkwu7.com1.z0.glb.clouddn.com/doge_sleep_icon.png" alt="A representation of Octdrey Catburn"></p>
<p>但是非常可惜的是，这种方法并不能调整图片的长宽，想要调整，还是得学习一点相关的Html语法。</p>
<h3 id="Blockquote（引用区块）">Blockquote（引用区块）</h3><p>引用区块就是利用一句话或者一个段落的特殊格式来引起读者注意的语法。要做到这件事情也是十分简单，只要在要引用的句子或段落的前面加上”greater than” caret（大于号）就可以了，例如：</p>
<blockquote>
<p>If you need to call special attention to a quote from another source, or design a pull quote for a magazine article, then Markdown’s blockquote syntax will be useful. A blockquote is a sentence or paragraph that’s been specially formatted to draw attention to the reader.</p>
<p>To create a block quote, all you have to do is preface a line with the “greater than” caret.</p>
</blockquote>
<p>Blockquote还支持嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt;</p>
<h3 id="Codeblock（代码区块）">Codeblock（代码区块）</h3><p>在Markdown里添加代码也非常简单，只需要缩进一个table（制表符）或者四个space（空格）就好了。<br>注意代码区块里斜体加粗引用等Markdown语法都会失效。</p>
<pre><code><span class="preprocessor">#inluce&lt;iostream&gt;</span>
<span class="keyword">using</span> namespce <span class="built_in">std</span>;

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{
    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, World!"</span> &lt;&lt; endl;
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><h3 id="创建列表">创建列表</h3><h5 id="第一种：Unordered_List（无序列表）">第一种：Unordered List（无序列表）</h5><p>It’s easy.在每一项的前面加上asterisk（星号）就好，记得星号后面要留一个space（空格）或table（制表符）哦，<strong>还有一个特殊的地方就是在这里plus sign（加号）和minus sign（减号）可以与asterisk混用。</strong></p>
<h5 id="第二种：Ordered_List（有序列表）">第二种：Ordered List（有序列表）</h5><p>有序列表就是数字加上一个半角句点和一个space或table就好了。但是要注意不小心产生有序列表的情况，所以尽量避免数字半角句点和space/table连续出现的情况，实在无法避免在句点前加上一个backslash（反斜杠）即可——<strong><em>反斜杠通常被利用来来插入一些在语法中有其它意义的符号(又被称作转义符)</em></strong>.</p>
<p>Remark：在实践中，我发现一个有趣的现象，就是有序列表只要制定了开头，后边的序号可以不用写，用asterisk/minus sign/plus sign代替也是可以，这样的话它会自动递增地帮你打印出序号来。</p>
<h5 id="多级列表的处理">多级列表的处理</h5><p>在新一级的标识符前加上table来缩进即可，打印出来的效果像这样</p>
<ul>
<li>First level<ul>
<li>Second level<ul>
<li>Third level<ul>
<li>Fourth level</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="创建表格">创建表格</h3><p>这个并不是<strong>Markdown</strong>的标准语法，似乎需要解释器，先看看能不能发上来。<br>示例：</p>
<pre><code>H1 |H2 |H3
---|---|---
<span class="number">0</span>,<span class="number">0</span>|<span class="number">0</span>,<span class="number">1</span>|<span class="number">0</span>,<span class="number">2</span>
<span class="number">1</span>,<span class="number">0</span>|<span class="number">1</span>,<span class="number">1</span>|<span class="number">1</span>,<span class="number">2</span>
<span class="number">2</span>,<span class="number">0</span>|<span class="number">2</span>,<span class="number">1</span>|<span class="number">2</span>,<span class="number">2</span>
</code></pre><table>
<thead>
<tr>
<th>H1</th>
<th>H2</th>
<th>H3</th>
</tr>
</thead>
<tbody>
<tr>
<td>0,0</td>
<td>0,1</td>
<td>0,2</td>
</tr>
<tr>
<td>1,0</td>
<td>1,1</td>
<td>1,2</td>
</tr>
<tr>
<td>2,0</td>
<td>2,1</td>
<td>2,2</td>
</tr>
</tbody>
</table>
<h3 id="段落和换行">段落和换行</h3><p>你在实际操作中会发现，即使你在编辑时输入return（回车），显示出来的仍旧是一行，在Marhdown语法里也有两种方式来实现换行：</p>
<h5 id="Hard_Break">Hard Break</h5><p>直接再输入一个return（回车），这样段落的间距比较大。</p>
<h5 id="Soft_Break">Soft Break</h5><p>在段末输两个连续的space（空格），这样段落的间距会比较小。</p>
<p>总的来说，Markdown语法还是十分简单易学的，还有就是建议大家还是在实践中学习会比较快。<br>最后，感谢这个Markdown教程的网站，它提供了训练式的Markdown学习，对我的帮助十分大。<a href="http://markdowntutorial.com/" target="_blank" rel="external">http://markdowntutorial.com/</a>也十分感谢<a href="http://www.appinn.com/markdown/#img" target="_blank" rel="external"><em>Markdown 语法说明 (简体中文版)</em></a>告诉我许多其他的语法作为补充</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>刚建好自己的小窝，第一篇正式的博文记录了自己学习的Markdown语法，毕竟以后都要使用它来写博客，大家多多指教。<br>]]>
    
    </summary>
    
      <category term="web" scheme="http://xmhtech.me/tags/web/"/>
    
      <category term="Tech" scheme="http://xmhtech.me/categories/Tech/"/>
    
  </entry>
  
</feed>